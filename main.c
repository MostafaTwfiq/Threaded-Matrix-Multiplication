#include <stdio.h>
#include <time.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <pthread.h>

typedef enum ERROR {

    ///The errors codes generated by summing the word characters ASCII value and multiply every character in it's ( index + 1 )
    ///The first four numbers is the sum of the sentence "DATA_STRUCTURE",
    ///and the rest of the error code is the sum of the error enum. ex: INVALID_ARG is 4987.

    FAILED_ALLOCATION = -833811484,
    FAILED_REALLOCATION = -833814245,
    FAILED_COPY = -83385167,
    INVALID_ARG = -83384987,
    NULL_POINTER = -83386157,
    OUT_OF_RANGE = -83385991,
    EMPTY_DATA_STRUCTURE = -833816740,
    SOMETHING_WENT_WRONG = -833816834
} ERROR;


#define         FAILED_ALLOCATION_MESSAGE           "The %s allocation in %s failed.\n"
#define         FAILED_REALLOCATION_MESSAGE         "The %s reallocation in %s failed.\n"
#define         FAILED_COPY_MESSAGE                 "Copying %s in %s failed.\n"
#define         INVALID_ARG_MESSAGE                 "The passed argument %s in %s is invalid.\n"
#define         NULL_POINTER_MESSAGE                "The %s pointer in %s is NULL.\n"
#define         OUT_OF_RANGE_MESSAGE                "The passed index is out of the %s range.\n"
#define         EMPTY_DATA_STRUCTURE_MESSAGE        "The passed %s pointer is empty.\n"
#define         SOMETHING_WENT_WRONG_MESSAGE        "Can't %s in %s.\n"



/** @struct String
*  @brief This structure implements a basic String.
*  @var String::string
*  Member 'string' is a pointer to the string char array.
*  @var String::count
*  Member 'count' holds the current number of characters.
*  @var String::length
*  Member 'length' holds the current length of the allocated char array.
*/

typedef struct String {
    char *string;
    int count;
    int length;
} String;

typedef struct Vector {
    void **arr;
    int length;
    int count;

    void (*freeItem)(void *);

    int (*comparator)(const void *, const void *);
} Vector;

typedef struct TxtFileLoader {
    char *dir;
    FILE *fileP;
} TxtFileLoader;


TxtFileLoader *txtFileLoaderInitialization(char *fileDir);

struct Vector *txtLoaderReadFileLines(TxtFileLoader *txtFileLoader);

void destroyTxtFileLoader(void *txtFileLoader);

Vector *vectorInitialization(int initialLength, void (*freeFun)(void *), int (*comparator)(const void *, const void *));

void vectorAdd(Vector *list, void *item);

void *vectorGet(Vector *list, int index);

int vectorGetLength(Vector *list);

void clearVector(Vector *list);

void destroyVector(void *list);

String *stringInitialization(int initialLength);

void stringAppendChar(String *string, char c);

char stringGet(String *string, int index);

int stringCompareS(const void *string, const void *sString);

int stringGetLength(String *string);

struct Vector *stringSplit(String *string, char *splitCharacters);

void destroyString(void *myString);


/** This function will allocate a new txt file loader then the memory,
 * and setup it's fields, and finally return the initialized txt file loader pointer.
 *
 * @param fileDir the direction of the text file
 * @return it will return the initialized txt file loader pointer.
 */

TxtFileLoader *txtFileLoaderInitialization(char *fileDir) {

    if (fileDir == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = INVALID_ARG;
        return NULL;
#else
        fprintf(stderr, INVALID_ARG_MESSAGE, "file direction", "text file loader");
        exit(INVALID_ARG);
#endif
    }

    TxtFileLoader *loader = (TxtFileLoader *) malloc(sizeof(TxtFileLoader));
    if (loader == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = FAILED_ALLOCATION;
        return NULL;
#else
        fprintf(stderr, FAILED_ALLOCATION_MESSAGE, "loader", "text file loader");
        exit(FAILED_ALLOCATION);
#endif
    }

    loader->dir = (char *) malloc(sizeof(char) * (strlen(fileDir) + 1));
    if (loader->dir == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = FAILED_ALLOCATION;
        return NULL;
#else
        fprintf(stderr, FAILED_ALLOCATION_MESSAGE, "file direction", "text file loader");
        exit(FAILED_ALLOCATION);
#endif
    }

    loader->dir = strcpy(loader->dir, fileDir);
    if (loader->dir == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = FAILED_COPY;
        return NULL;
#else
        fprintf(stderr, FAILED_COPY_MESSAGE, "file direction", "text file loader");
        exit(FAILED_COPY);
#endif
    }

    return loader;

}


/** This function will open the file.
 *
 * @param txtFileLoader the text file loader pointer
 * */

void txtLoaderOpenFile(TxtFileLoader *txtFileLoader, char *openType) {

    if (txtFileLoader == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "loader", "text file loader");
        exit(NULL_POINTER);
#endif
    }

    txtFileLoader->fileP = fopen(txtFileLoader->dir, openType);
    if (txtFileLoader->fileP == NULL) {
        fprintf(stderr, SOMETHING_WENT_WRONG_MESSAGE, "open the file", "text file loader");
        exit(SOMETHING_WENT_WRONG);
    }

}

Vector *txtLoaderReadFileLines(TxtFileLoader *txtFileLoader) {

    if (txtFileLoader == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return NULL;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "loader", "text file loader");
        exit(NULL_POINTER);
#endif
    }

    txtLoaderOpenFile(txtFileLoader, "r");

    Vector *linesVector = vectorInitialization(10, destroyString, stringCompareS);
    vectorAdd(linesVector, stringInitialization(10));
    int stringIndex = 0;
    char c;
    while ((c = (char) fgetc(txtFileLoader->fileP)) != EOF) {

        if (c == '\n') {
            stringIndex++;
            vectorAdd(linesVector, stringInitialization(10));
            continue;
        }

        stringAppendChar((String *)vectorGet(linesVector, stringIndex), c);

    }


    fseek(txtFileLoader->fileP, 0, SEEK_SET);

    fclose(txtFileLoader->fileP);
    return linesVector;

}


/** This function will destroy and free the passed text file loader.
 *
 * @param txtFileLoader the text file loader pointer
 */

void destroyTxtFileLoader(void *txtFileLoader) {

    if (txtFileLoader == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "loader", "text file loader");
        exit(NULL_POINTER);
#endif
    }

    free( ((TxtFileLoader *) txtFileLoader)->dir );
    free(txtFileLoader);

}


/** This function will take the initial length of the vector, and the freeing and comparator functions as a parameter,
 * then it will initialize a new vector in the memory and set it's fields then return it.
 *
 * @param initialLength the initial length of the vector.
 * @param freeFun the function address that will be called to free the vector items.
 * @param comparator the comparator function address, that will be called to compare two items in the vector
 * @return it will return the initialized vector pointer
 */

Vector *
vectorInitialization(int initialLength, void (*freeFun)(void *), int (*comparator)(const void *, const void *)) {
    if (freeFun == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = INVALID_ARG;
        return NULL;
#else
        fprintf(stderr, INVALID_ARG_MESSAGE, "free function", "vector data structure");
        exit(INVALID_ARG);
#endif

    } else if (initialLength <= 0) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = INVALID_ARG;
        return NULL;
#else
        fprintf(stderr, INVALID_ARG_MESSAGE, "initial length", "vector data structure");
        exit(INVALID_ARG);
#endif

    }

    Vector *list = (Vector *) malloc(sizeof(Vector));
    if (list == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = FAILED_ALLOCATION;
        return NULL;
#else
        fprintf(stderr, FAILED_ALLOCATION_MESSAGE, "data structure", "vector data structure");
        exit(FAILED_ALLOCATION);
#endif

    }

    list->arr = (void **) malloc(sizeof(void *) * initialLength);
    if (list->arr == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = FAILED_ALLOCATION;
        return NULL;
#else
        fprintf(stderr, FAILED_ALLOCATION_MESSAGE, "items memory", "vector data structure");
        exit(FAILED_ALLOCATION);
#endif

    }

    list->length = initialLength > 0 ? initialLength : 1;
    list->count = 0;
    list->freeItem = freeFun;
    list->comparator = comparator;

    return list;
}


/** This function will take the vector address, and the item address as a parameters,
 * then it will put the item in the end of the vector.
 *
 * @param list the vector address
 * @param item the item address
 */

void vectorAdd(Vector *list, void *item) {

    if (list == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "vector", "vector data structure");
        exit(NULL_POINTER);
#endif

    } else if (item == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = INVALID_ARG;
        return;
#else
        fprintf(stderr, INVALID_ARG_MESSAGE, "item pointer", "vector data structure");
        exit(INVALID_ARG);
#endif

    }

    if (list->count == list->length) {
        list->length *= 2;

        list->arr = (void **) realloc(list->arr, sizeof(void *) * list->length);
        if (list->arr == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
            ERROR_TEST->errorCode = FAILED_REALLOCATION;
            return;
#else
            fprintf(stderr, FAILED_REALLOCATION_MESSAGE, "items memory", "vector data structure");
            exit(FAILED_REALLOCATION);
#endif

        }

    }


    list->arr[list->count++] = item;

}

/** This function will take the vector address as a parameter,
 * then it will return the length of the vector.
 *
 * @param list the vector address
 * @return it will return the number of items in the vector
 */

int vectorGetLength(Vector *list) {

    if (list == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return -1;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "vector", "vector data structure");
        exit(NULL_POINTER);
#endif

    }

    return list->count;

}


/** This function will take the vector address, and the index as a parameters,
 * then it will return the item at the given index.
 *
 * Note: if the index is out of the vector range then the program will be terminated.
 *
 * @param list the vector address
 * @param index the item index
 * @return it will return a void pointer to the item
 */

void *vectorGet(Vector *list, int index) {
    if (list == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return NULL;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "vector", "vector data structure");
        exit(NULL_POINTER);
#endif

    } else if (index < 0 || index >= vectorGetLength(list)) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = OUT_OF_RANGE;
        return NULL;
#else
        fprintf(stderr, OUT_OF_RANGE_MESSAGE, "vector data structure");
        exit(OUT_OF_RANGE);
#endif

    }

    return list->arr[index];

}


/** This function will take the vector address as a parameter,
 * then it will destroy and free all the vector items.
 *
 * Note: the function will just clear the vector, but it will not destroy the vector.
 *
 * @param list the vector address
 */

void clearVector(Vector *list) {

    if (list == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "vector", "vector data structure");
        exit(NULL_POINTER);
#endif

    }

    for (int i = 0; i < vectorGetLength(list); i++)
        list->freeItem(list->arr[i]);


    list->count = 0;

}


/** This function will take the vector address as a parameter,
 * then it will destroy and free the vector and all it's items.
 *
 * @param list the vector address
 */

void destroyVector(void *list) {

    if (list == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "vector", "vector data structure");
        exit(NULL_POINTER);
#endif

    }

    clearVector((Vector *)list);
    free(((Vector *) list)->arr);
    free(list);

}

/** This function will take the initial length of the string as a parameter,
 * then it will initialize a new String pointer and return it.
 *
 * @param initialLength the string initial length
 * @return it will return the initialized string
 */

String *stringInitialization(int initialLength) {
    if (initialLength <= 0) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = INVALID_ARG;
        return NULL;
#else
        fprintf(stderr, INVALID_ARG_MESSAGE, "initial length", "string data structure");
        exit(INVALID_ARG);
#endif

    }

    String *myString = (String *) malloc(sizeof(String));
    if (myString == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = FAILED_ALLOCATION;
        return NULL;
#else
        fprintf(stderr, FAILED_ALLOCATION_MESSAGE, "string", "string data structure");
        exit(FAILED_ALLOCATION);
#endif

    }

    myString->string = (char *) malloc(sizeof(char) * (initialLength + 1));
    if (myString->string == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = FAILED_ALLOCATION;
        return NULL;
#else
        fprintf(stderr, FAILED_ALLOCATION_MESSAGE, "string array", "string data structure");
        exit(FAILED_ALLOCATION);
#endif

    }

    myString->string[0] = '\0';
    myString->count = 0;
    myString->length = initialLength;

    return myString;
}


/** This function will take the string address, and the new character as a parameter,
 * then it will put the new character in the end of the string.
 *
 * @param string the string address
 * @param c the new character
 */

void stringAppendChar(String *string, char c) {
    if (string == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "string", "string data structure");
        exit(NULL_POINTER);
#endif

    }

    if (string->count == string->length) {
        string->length *= 2;
        string->string = (char *) realloc(string->string, sizeof(char) * (string->length + 1));
        if (string->string == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
            ERROR_TEST->errorCode = FAILED_REALLOCATION;
            return;
#else
            fprintf(stderr, FAILED_REALLOCATION_MESSAGE, "string array", "string data structure");
            exit(FAILED_REALLOCATION);
#endif

        }

    }

    string->string[string->count++] = c;
    string->string[string->count] = '\0';

}


/** This function will take the string address, and the index as a parameter,
 * then it will remove the character in the given index.
 *
 * Note: if the index is out of the string range the program will terminate.
 *
 * @param string the string address
 * @param index the index of the char that will be removed
 */

void stringRemove(String *string, int index) {
    if (string == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "string", "string data structure");
        exit(NULL_POINTER);
#endif

    } else if (string->count <= index || index < 0) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = OUT_OF_RANGE;
        return;
#else
        fprintf(stderr, OUT_OF_RANGE_MESSAGE, "string data structure");
        exit(OUT_OF_RANGE);
#endif

    }

    for (int i = index; i < string->count; i++)
        string->string[i] = string->string[i + 1];

    string->count--;

}



/** This function will take the string address, and the index as a parameters,
 * then it will return the character at the given index.
 *
 * Note: if the index is out of the string range the program will terminate.
 *
 * @param string the string address
 * @param index the index of the wanted character
 * @return it will return the character at the provided index
 */

char stringGet(String *string, int index) {
    if (string == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return '\0';
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "string", "string data structure");
        exit(NULL_POINTER);
#endif

    } else if (string->count <= index || index < 0) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = OUT_OF_RANGE;
        return '\0';
#else
        fprintf(stderr, OUT_OF_RANGE_MESSAGE, "string data structure");
        exit(OUT_OF_RANGE);
#endif

    }

    return string->string[index];

}



/** This function will take the string address as a parameter,
 * then it will return the string length.
 *
 * @param string the string address
 * @return it will return the length of the string
 */

int stringGetLength(String *string) {
    if (string == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return -1;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "string", "string data structure");
        exit(NULL_POINTER);
#endif

    }

    return string->count;
}


/** This function will take the string address, and second string address as a parameters,
 * then it will compare the strings and it will return a zero if they are equal,
 * negative number if the second one is bigger, and positive number if the first is bigger.
 *
 * @param string the string address
 * @param sString the other string address
 * @return it will return a zero if they are equal, negative number if the second one is bigger, and positive number if the first is bigger.
*/

int stringCompareS(const void *string, const void *sString) {
    if (string == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return -1;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "string", "string data structure");
        exit(NULL_POINTER);
#endif

    } else if (sString == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = INVALID_ARG;
        return -1;
#else
        fprintf(stderr, INVALID_ARG_MESSAGE, "second string pointer", "string data structure");
        exit(INVALID_ARG);
#endif

    }

    char *fS = ((String *) string)->string;
    char *sS = ((String *) sString)->string;

    while (*fS != '\0' && *sS != '\0') {

        if (*fS != *sS)
            return *fS - *sS;

        fS++;
        sS++;

    }

    if (*fS == '\0' && *sS == '\0')
        return 0;

    return *fS == '\0' ? -1 * (int) *sS : (int) *fS;

}


/** This function will return one (1) if the passed characters is a part of the passed character array,
 * other wise if will return zero (0).
 *
 * @param charArr the char array pointer
 * @param c the character value, that the function will search for
 * @return it will return one if the character value exist in the char array, other wise it will return zero
 */

int charArrContains(char *charArr, char c) {

    while (*charArr != '\0') {
        if (*charArr++ == c)
            return 1;

    }

    return 0;

}


/** This function will take string pointer,
 * then it will removes characters specified in the second array of characters parameter,
 * from the beginning of the string.
 *
 * ex of specialCharacters array:
 * " \t\n", the function will remove any ' ', '\t', and '\n' characters from the beginning.
 *
 * @param string the string pointer
 * @param specialCharacters the special characters array pointer
 */

void stringCustomTrimStart(String *string, char *specialCharacters) {

    if (string == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "string", "string data structure");
        exit(NULL_POINTER);
#endif

    } else if (specialCharacters == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = INVALID_ARG;
        return;
#else
        fprintf(stderr, INVALID_ARG_MESSAGE, "special characters array", "string data structure");
        exit(INVALID_ARG);
#endif
    }

    char *charArr = string->string;
    while (*charArr != '\0') {

        if (charArrContains(specialCharacters, *charArr)) {
            char *tempPointer = charArr;

            do {
                *tempPointer = *(tempPointer + 1);
            } while (*tempPointer++ != '\0');

            string->count--;

        } else
            break;

    }


}


/** This function will take string pointer,
 * then it will removes characters specified in the second array of characters parameter,
 * from the end of the string.
 *
 * ex of specialCharacters array:
 * " \t\n", the function will remove any ' ', '\t', and '\n' characters from the end.
 *
 * @param string the string pointer
 * @param specialCharacters the special characters array pointer
 */

void stringCustomTrimEnd(String *string, char *specialCharacters) {

    if (string == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "string", "string data structure");
        exit(NULL_POINTER);
#endif

    } else if (specialCharacters == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = INVALID_ARG;
        return;
#else
        fprintf(stderr, INVALID_ARG_MESSAGE, "special characters array", "string data structure");
        exit(INVALID_ARG);
#endif
    }

    char *charArr = string->string;
    char *startPointer = string->string;

    while (*charArr != '\0')
        charArr++;

    while (startPointer - sizeof(char) != --charArr && charArrContains(specialCharacters, *charArr)) {
        *charArr = '\0';
        string->count--;
    }

}



/** This function will take a string,
 * then it will split it by the passed split characters array.
 *
 * ex of split characters array:
 * " \t\n", the function will split the string when ever it see ' ', '\t', or '\n' characters.
 *
 * @param string the string pointer
 * @param splitCharacters the split characters array pointer
 * @return it will return a vector contains the strings after split
 */

Vector *stringSplit(String *string, char *splitCharacters) {

    if (string == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return NULL;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "string", "string data structure");
        exit(NULL_POINTER);
#endif

    } else if (splitCharacters == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = INVALID_ARG;
        return NULL;
#else
        fprintf(stderr, INVALID_ARG_MESSAGE, "split characters array", "string data structure");
        exit(INVALID_ARG);
#endif
    }


    Vector *stringsVector = vectorInitialization(5, destroyString, stringCompareS);
    vectorAdd(stringsVector, stringInitialization(5));

    for (int i = 0; i < stringGetLength(string); i++) {

        if (charArrContains(splitCharacters, stringGet(string, i))) {

            if (stringGetLength((String *)vectorGet(stringsVector, vectorGetLength(stringsVector) - 1)) != 0)
                vectorAdd(stringsVector, stringInitialization(5));

            continue;
        }

        stringAppendChar((String *) vectorGet(stringsVector, vectorGetLength(stringsVector) - 1), stringGet(string, i));

    }

    return stringsVector;

}


/** This function will take the string address as a parameter,
 * then it will destroy and free the string from the memory.
 *
 * @param myString the string address
 */

void destroyString(void *myString) {
    if (myString == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "string", "string data structure");
        exit(NULL_POINTER);
#endif

    }

    free(((String *) myString)->string);
    free(myString);

}

typedef struct Param {
    int m1R, m1C, m2R, m2C, *fMatrix, *sMatrix, *answerMatrix, r, c;
} Param;

void *calElement(void *p) {
    Param *param = (Param *) p;
    int m1R = param->m1R, m1C = param->m1C, m2R = param->m2R, m2C = param->m2C,
            *fMatrix = param->fMatrix, *sMatrix = param->sMatrix, *answerMatrix = param->answerMatrix, r = param->r, c = param->c;
    int sum = 0;

    for (int i = 0; i < m1C; i++) {
        sum += fMatrix[r * m1C + i] * sMatrix[i * m2C + c];
    }
    answerMatrix[r * m2C + c] = sum;
    pthread_exit(NULL);

}

void *calRow(void *p) {
    Param *param = (Param *) p;
    int m1R = param->m1R, m1C = param->m1C, m2R = param->m2R, m2C = param->m2C,
            *fMatrix = param->fMatrix, *sMatrix = param->sMatrix, *answerMatrix = param->answerMatrix, r = param->r;

    int sum;
    for (int i = 0; i < m2C; i++) {
        sum = 0;
        for (int j = 0; j < m1C; j++) {
            sum += fMatrix[r * m1C + j] * sMatrix[j * m2C + i];
        }
        answerMatrix[r * m2C + i] = sum;
    }

    pthread_exit(NULL);
}

int main() {

    double time_spent;
    clock_t begin, end;
    int m1R, m1C, m2R, m2C, currThread;

    char filePath[] = "input.txt";
    TxtFileLoader *txtFileLoader = txtFileLoaderInitialization(filePath);
    Vector *fileLines = txtLoaderReadFileLines(txtFileLoader);
    if (vectorGetLength(fileLines) < 4) {
        fprintf(stderr, "The file isn't valid.");
        exit(-1);
    }

    String *fMatrixSizeLine = (String *) vectorGet(fileLines, 0);
    Vector *fMatrixSizeSplitted = stringSplit(fMatrixSizeLine, " ");
    if (vectorGetLength(fMatrixSizeSplitted) != 2) {
        fprintf(stderr, "The file isn't valid.");
        exit(-1);
    }

    m1R = atoi(((String *) vectorGet(fMatrixSizeSplitted, 0))->string);
    m1C = atoi(((String *) vectorGet(fMatrixSizeSplitted, 1))->string);

    destroyVector(fMatrixSizeSplitted);
    Vector *splittedLine;

    int fMatrix[m1R][m1C];
    for (int i = 1; i <= m1R; i++) {
        splittedLine = stringSplit((String *) vectorGet(fileLines, i), " ");
        if (vectorGetLength(splittedLine) != m1C) {
            fprintf(stderr, "The file isn't valid.");
            exit(-1);
        }
        for (int j = 0; j < m1C; j++)
            fMatrix[i - 1][j] = atoi(((String  *) vectorGet(splittedLine, j))->string);

        destroyVector(splittedLine);
    }


    String *sMatrixSizeLine = (String *) vectorGet(fileLines, m1R + 1);
    Vector *sMatrixSizeSplitted = stringSplit(sMatrixSizeLine, " ");
    if (vectorGetLength(sMatrixSizeSplitted) != 2) {
        fprintf(stderr, "The file isn't valid.");
        exit(-1);
    }

    m2R = atoi(((String *) vectorGet(sMatrixSizeSplitted, 0))->string);
    m2C = atoi(((String *) vectorGet(sMatrixSizeSplitted, 1))->string);

    destroyVector(sMatrixSizeSplitted);

    int sMatrix[m2R][m2C];
    for (int i = m1R + 2; i <= m2R + m1R + 1; i++) {
        splittedLine = stringSplit((String  *) vectorGet(fileLines, i), " ");
        if (vectorGetLength(splittedLine) != m2C) {
            fprintf(stderr, "The file isn't valid.");
            exit(-1);
        }
        for (int j = 0; j < m2C; j++)
            sMatrix[i - m1R - 2][j] = atoi(((String  *) vectorGet(splittedLine, j))->string);

        destroyVector(splittedLine);
    }

    destroyTxtFileLoader(txtFileLoader);
    destroyVector(fileLines);

    int answerMatrix[m1R][m2C];
    pthread_t threads_id[m1R * m2C];
    Param params[m1R * m2C];
    for (int i = 0; i < m1R * m2C; i++) {
        params[i].m1R = m1R;
        params[i].m1C = m1C;
        params[i].m2R = m2R;
        params[i].m2C = m2C;
        params[i].fMatrix = (int *) fMatrix;
        params[i].sMatrix = (int *) sMatrix;
        params[i].answerMatrix = (int *) answerMatrix;
    }

    FILE *ansFile = fopen("ans.txt", "w");
    if (!ansFile) {
        fprintf(stderr, "Can't create answer file.");
        exit(-1);
    }

    // start of method 1:
    begin = clock();

    for (int i = 0; i < m1R; i++) {
        currThread = i;
        params[currThread].r = i;
        pthread_create(threads_id + currThread, NULL, calRow, params + currThread);
    }

    for (int i = 0; i < m1R; i++) {
        if (pthread_join(threads_id[i], NULL))
            fprintf(stderr, "Some thing went wrong.");

    }

    end = clock();
    time_spent = (double)(end - begin) / CLOCKS_PER_SEC;

    fprintf(ansFile,"By Row\n");
    for (int i = 0; i < m1R; i++) {
        for (int j = 0; j < m2C; j++) {
            fprintf(ansFile,"%d%c", answerMatrix[i][j], j == m2C - 1 ? '\n' : ' ');
        }
    }

    fprintf(ansFile, "Time : %f s\n\n", time_spent);
    // end of method 1.

    // start of method 2:
    begin = clock();
    for (int i = 0; i < m1R; i++) {
        for (int j = 0; j < m2C; j++) {
            currThread = i * m2C + j;
            params[currThread].r = i;
            params[currThread].c = j;
            pthread_create(threads_id + currThread, NULL, calElement, params + currThread);
        }
    }

    for (int i = 0; i < m1R * m2C; i++) {
        if (pthread_join(threads_id[i], NULL))
            fprintf(stderr, "Some thing went wrong.");

    }

    end = clock();
    time_spent = (double)(end - begin) / CLOCKS_PER_SEC;

    fprintf(ansFile, "By Element\n");
    for (int i = 0; i < m1R; i++) {
        for (int j = 0; j < m2C; j++) {
            fprintf(ansFile,"%d%c", answerMatrix[i][j], j == m2C - 1 ? '\n' : ' ');
        }
    }

    fprintf(ansFile, "Time : %f s", time_spent);
    // finish of method 2.

    fclose(ansFile);
    return 0;
}
