#include <stdio.h>
#include <time.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <pthread.h>

typedef enum ERROR {

    ///The errors codes generated by summing the word characters ASCII value and multiply every character in it's ( index + 1 )
    ///The first four numbers is the sum of the sentence "DATA_STRUCTURE",
    ///and the rest of the error code is the sum of the error enum. ex: INVALID_ARG is 4987.

    FAILED_ALLOCATION = -833811484,
    FAILED_REALLOCATION = -833814245,
    FAILED_COPY = -83385167,
    INVALID_ARG = -83384987,
    NULL_POINTER = -83386157,
    OUT_OF_RANGE = -83385991,
    EMPTY_DATA_STRUCTURE = -833816740,
    SOMETHING_WENT_WRONG = -833816834
} ERROR;


#define         FAILED_ALLOCATION_MESSAGE           "The %s allocation in %s failed.\n"
#define         FAILED_REALLOCATION_MESSAGE         "The %s reallocation in %s failed.\n"
#define         FAILED_COPY_MESSAGE                 "Copying %s in %s failed.\n"
#define         INVALID_ARG_MESSAGE                 "The passed argument %s in %s is invalid.\n"
#define         NULL_POINTER_MESSAGE                "The %s pointer in %s is NULL.\n"
#define         OUT_OF_RANGE_MESSAGE                "The passed index is out of the %s range.\n"
#define         EMPTY_DATA_STRUCTURE_MESSAGE        "The passed %s pointer is empty.\n"
#define         SOMETHING_WENT_WRONG_MESSAGE        "Can't %s in %s.\n"



/** @struct String
*  @brief This structure implements a basic String.
*  @var String::string
*  Member 'string' is a pointer to the string char array.
*  @var String::count
*  Member 'count' holds the current number of characters.
*  @var String::length
*  Member 'length' holds the current length of the allocated char array.
*/

typedef struct String {
    char *string;
    int count;
    int length;
} String;

typedef struct Vector {
    void **arr;
    int length;
    int count;

    void (*freeItem)(void *);

    int (*comparator)(const void *, const void *);
} Vector;

typedef struct TxtFileLoader {
    char *dir;
    FILE *fileP;
} TxtFileLoader;


TxtFileLoader *txtFileLoaderInitialization(char *fileDir);

struct String *txtLoaderReadFileS(TxtFileLoader *txtFileLoader);

char *txtLoaderReadFileC(TxtFileLoader *txtFileLoader);

struct Vector *txtLoaderReadFileLines(TxtFileLoader *txtFileLoader);

struct Vector *txtLoaderReadFileWthDelimiter(TxtFileLoader *txtFileLoader, char *delimiter);

int txtLoaderCountLines(TxtFileLoader *txtFileLoader);

struct String *txtLoaderReadLineS(TxtFileLoader *txtFileLoader, int lineIndex);

char *txtLoaderReadLineC(TxtFileLoader *txtFileLoader, int lineIndex);

void txtLoaderWriteC(TxtFileLoader *txtFileLoader, char *data);

void txtLoaderWriteS(TxtFileLoader *txtFileLoader, struct String *data);

void txtLoaderAppendC(TxtFileLoader *txtFileLoader, char *data);

void txtLoaderAppendS(TxtFileLoader *txtFileLoader, struct String *data);

void txtLoaderAppendAllC(TxtFileLoader *txtFileLoader, struct Vector *newLines);

void txtLoaderAppendAllS(TxtFileLoader *txtFileLoader, struct Vector *newLines);

void txtLoaderAppendToLineC(TxtFileLoader *txtFileLoader, char *lineToAppend, int index);

void txtLoaderAppendToLineS(TxtFileLoader *txtFileLoader, struct String *stringToAppend, int index);

void txtLoaderAddLineC(TxtFileLoader *txtFileLoader, char *line, int index);

void txtLoaderAddLineS(TxtFileLoader *txtFileLoader, struct String *line, int index);

void txtLoaderAddAllC(TxtFileLoader *txtFileLoader, struct Vector *newLines, int index);

void txtLoaderAddAllS(TxtFileLoader *txtFileLoader, struct Vector *newLines, int index);

void txtLoaderUpdateLineC(TxtFileLoader *txtFileLoader, char *line, int index);

void txtLoaderUpdateLineS(TxtFileLoader *txtFileLoader, struct String *line, int index);

void txtLoaderRemoveLine(TxtFileLoader *txtFileLoader, int index);

void txtLoaderClearFile(TxtFileLoader *txtFileLoader);

void txtLoaderChangeFile(TxtFileLoader *txtFileLoader, char *newFileDir);

void destroyTxtFileLoader(void *txtFileLoader);

Vector *vectorInitialization(int initialLength, void (*freeFun)(void *), int (*comparator)(const void *, const void *));

void vectorAdd(Vector *list, void *item);

void vectorAddAtIndex(Vector *list, void *item, int index);

void vectorAddAll(Vector *list, void **array, int arrayLength);

void vectorRemove(Vector *list);

void *vectorRemoveWtFr(Vector *list);

void vectorRemoveAtIndex(Vector *list, int index);

void *vectorRemoveAtIndexWtFr(Vector *list, int index);

int vectorContains(Vector *list, void *item);

int vectorGetIndex(Vector *list, void *item);

int vectorGetLastIndex(Vector *list, void *item);

void *vectorGet(Vector *list, int index);

void **vectorToArray(Vector *list);

void **vectorToSubArray(Vector *list, int start, int end);

void vectorSort(Vector *list, int (*sortComp)(const void *, const void *));

int vectorGetLength(Vector *list);

int vectorIsEmpty(Vector *list);

void printVector(Vector *list, void (*printFun)(const void *));

void clearVector(Vector *list);

void destroyVector(void *list);

String *stringInitialization(int initialLength);

void stringAppendChar(String *string, char c);

void stringAddChar(String *string, int index, char c);

void stringUpdateChar(String *string, int index, char c);

void stringRemove(String *string, int index);

void stringAppendC(String *string, char *charArr);

void stringAppendS(String *string, String *newString);

void stringChangeStringC(String *string, char *newCharArr);

void stringChangeStringS(String *string, String *newString);

int stringGetIndex(String *string, char c);

char stringGet(String *string, int index);

int stringSubStringC(String *string, char *charArr);

int stringSubStringS(String *string, String *sString);

char *stringToCharArray(String *string);

char *stringToCustomCharArray(String *string, int startIndex, int endIndex);

int stringEqualsC(String *string, char *charArr);

int stringEqualsS(String *string, String *sString);

int stringCompareC(String *string, char *charArr);

int stringCompareS(const void *string, const void *sString);

int stringGetLength(String *string);

void stringCustomTrimStart(String *string, char *specialCharacters);

void stringTrimStart(String *string);

void stringCustomTrimEnd(String *string, char *specialCharacters);

void stringTrimEnd(String *string);

void stringTrim(String *myString);

void stringCustomTrim(String *string, char *specialCharacters);

void stringScanInput(String *string, FILE *dir);

void printString(String *string, FILE *dir);

struct Vector *stringSplit(String *string, char *splitCharacters);

void clearString(String *string);

void destroyString(void *myString);


/** This function will allocate a new txt file loader then the memory,
 * and setup it's fields, and finally return the initialized txt file loader pointer.
 *
 * @param fileDir the direction of the text file
 * @return it will return the initialized txt file loader pointer.
 */

TxtFileLoader *txtFileLoaderInitialization(char *fileDir) {

    if (fileDir == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = INVALID_ARG;
        return NULL;
#else
        fprintf(stderr, INVALID_ARG_MESSAGE, "file direction", "text file loader");
        exit(INVALID_ARG);
#endif
    }

    TxtFileLoader *loader = (TxtFileLoader *) malloc(sizeof(TxtFileLoader));
    if (loader == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = FAILED_ALLOCATION;
        return NULL;
#else
        fprintf(stderr, FAILED_ALLOCATION_MESSAGE, "loader", "text file loader");
        exit(FAILED_ALLOCATION);
#endif
    }

    loader->dir = (char *) malloc(sizeof(char) * (strlen(fileDir) + 1));
    if (loader->dir == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = FAILED_ALLOCATION;
        return NULL;
#else
        fprintf(stderr, FAILED_ALLOCATION_MESSAGE, "file direction", "text file loader");
        exit(FAILED_ALLOCATION);
#endif
    }

    loader->dir = strcpy(loader->dir, fileDir);
    if (loader->dir == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = FAILED_COPY;
        return NULL;
#else
        fprintf(stderr, FAILED_COPY_MESSAGE, "file direction", "text file loader");
        exit(FAILED_COPY);
#endif
    }

    return loader;

}


/** This function will open the file.
 *
 * @param txtFileLoader the text file loader pointer
 * */

void txtLoaderOpenFile(TxtFileLoader *txtFileLoader, char *openType) {

    if (txtFileLoader == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "loader", "text file loader");
        exit(NULL_POINTER);
#endif
    }

    txtFileLoader->fileP = fopen(txtFileLoader->dir, openType);
    if (txtFileLoader->fileP == NULL) {
        fprintf(stderr, SOMETHING_WENT_WRONG_MESSAGE, "open the file", "text file loader");
        exit(SOMETHING_WENT_WRONG);
    }

}


/** This function will load the file into a string,
 * then it will return the string pointer.
 *
 * @param txtFileLoader the text file loader pointer
 * @return it will return the loaded string pointer
 */

String *txtLoaderReadFileS(TxtFileLoader *txtFileLoader) {

    if (txtFileLoader == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return NULL;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "loader", "text file loader");
        exit(NULL_POINTER);
#endif
    }

    txtLoaderOpenFile(txtFileLoader, "r");

    String *fString = stringInitialization(10);
    char c;
    while ((c = (char) fgetc(txtFileLoader->fileP)) != EOF)
        stringAppendChar(fString, c);

    fseek(txtFileLoader->fileP, 0, SEEK_SET);

    fclose(txtFileLoader->fileP);

    return fString;

}


/** This function will load the file into a char array,
 * then it will return the string pointer.
 *
 * Note: this function will load the file into a string first,
 * then it will convert the string to char array.
 *
 * @param txtFileLoader the text file loader pointer
 * @return it will return the loaded char array pointer
 */

char *txtLoaderReadFileC(TxtFileLoader *txtFileLoader) {

    if (txtFileLoader == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return NULL;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "loader", "text file loader");
        exit(NULL_POINTER);
#endif
    }

    txtLoaderOpenFile(txtFileLoader, "r");

    String *fString = stringInitialization(10);
    char c;
    while ((c = (char) fgetc(txtFileLoader->fileP)) != EOF)
        stringAppendChar(fString, c);

    fseek(txtFileLoader->fileP, 0, SEEK_SET);

    char *fileCharArr = stringToCharArray(fString);
    destroyString(fString);

    fclose(txtFileLoader->fileP);
    return fileCharArr;

}


/** This function will load the file lines into strings,
 * and it will but the lines strings into a vector,
 * and finally return the vector pointer.
 *
 * @param txtFileLoader the text file loader pointer
 * @return it will return the lines vector
 */

Vector *txtLoaderReadFileLines(TxtFileLoader *txtFileLoader) {

    if (txtFileLoader == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return NULL;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "loader", "text file loader");
        exit(NULL_POINTER);
#endif
    }

    txtLoaderOpenFile(txtFileLoader, "r");

    Vector *linesVector = vectorInitialization(10, destroyString, stringCompareS);
    vectorAdd(linesVector, stringInitialization(10));
    int stringIndex = 0;
    char c;
    while ((c = (char) fgetc(txtFileLoader->fileP)) != EOF) {

        if (c == '\n') {
            stringIndex++;
            vectorAdd(linesVector, stringInitialization(10));
            continue;
        }

        stringAppendChar(vectorGet(linesVector, stringIndex), c);

    }


    fseek(txtFileLoader->fileP, 0, SEEK_SET);

    fclose(txtFileLoader->fileP);
    return linesVector;

}


int charArrContainsTxtFileLoader(char *arr, char c) {

    while (*arr != '\0') {

        if (*arr++ == c)
            return 1;

    }

    return 0;

}


/** This function will load the file lines into strings,
 * and it will but the lines strings into a vector,
 * and finally return the vector pointer.
 *
 * Ex for a delimiter: ( ",\n" ) the string will split at ',' and '\n' characters.
 *
 * @param txtFileLoader the text file loader pointer
 * @param delimiter the characters that the string will split at.
 * @return it will return the lines vector
 */

Vector *txtLoaderReadFileWthDelimiter(TxtFileLoader *txtFileLoader, char *delimiter) {

    if (txtFileLoader == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return NULL;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "loader", "text file loader");
        exit(NULL_POINTER);
#endif
    } else if (delimiter == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = INVALID_ARG;
        return NULL;
#else
        fprintf(stderr, INVALID_ARG_MESSAGE, "delimiter pointer", "text file loader");
        exit(INVALID_ARG);
#endif
    }

    txtLoaderOpenFile(txtFileLoader, "r");

    Vector *linesVector = vectorInitialization(10, destroyString, stringCompareS);
    vectorAdd(linesVector, stringInitialization(10));
    int stringIndex = 0;
    char c;
    while ((c = (char) fgetc(txtFileLoader->fileP)) != EOF) {

        if (charArrContainsTxtFileLoader(delimiter, c)) {
            stringIndex++;
            vectorAdd(linesVector, stringInitialization(10));
            continue;
        }

        stringAppendChar(vectorGet(linesVector, stringIndex), c);

    }


    fseek(txtFileLoader->fileP, 0, SEEK_SET);

    fclose(txtFileLoader->fileP);
    return linesVector;

}


/** This function will count the file lines, then return it.
 *
 * @param txtFileLoader the text file loader pointer
 * @return it will return the lines vector
 */

int txtLoaderCountLines(TxtFileLoader *txtFileLoader) {

    if (txtFileLoader == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return -1;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "loader", "text file loader");
        exit(NULL_POINTER);
#endif
    }

    txtLoaderOpenFile(txtFileLoader, "r");

    int counter = 1;
    char c = (char) fgetc(txtFileLoader->fileP);
    if (c == EOF)
        counter = 0;

    while ((c = (char) fgetc(txtFileLoader->fileP)) != EOF) {

        if (c == '\n')
            counter++;

    }


    fseek(txtFileLoader->fileP, 0, SEEK_SET);

    fclose(txtFileLoader->fileP);

    return counter;

}


/** This function will read the provided line index form the file,
 * then it will return the line as a string.
 *
 * Note: if the function didn't found the line with the provided index it will return NULL.
 *
 * @param txtFileLoader the text file loader pointer
 * @param lineIndex the line index
 * @return it will return the line string pointer if found, other wise it will return NULL
 */

String *txtLoaderReadLineS(TxtFileLoader *txtFileLoader, int lineIndex) {

    if (txtFileLoader == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return NULL;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "loader", "text file loader");
        exit(NULL_POINTER);
#endif
    }

    txtLoaderOpenFile(txtFileLoader, "r");

    char c;
    int currentIndex = 0;

    while (currentIndex != lineIndex && (c = (char) fgetc(txtFileLoader->fileP)) != EOF) {

        if (c == '\n')
            currentIndex++;

    }


    if (currentIndex != lineIndex && c == EOF) {
        fclose(txtFileLoader->fileP);
        return NULL;
    }

    String *lineString = stringInitialization(5);
    while ((c = (char) fgetc(txtFileLoader->fileP)) != EOF && c != '\n')
        stringAppendChar(lineString, c);


    fclose(txtFileLoader->fileP);
    return lineString;

}


/** This function will read the provided line index form the file,
 * then it will return the line as a char array.
 *
 * Note: if the function didn't found the line with the provided index it will return NULL.
 *
 * @param txtFileLoader the text file loader pointer
 * @param lineIndex the line index
 * @return it will return the line char array pointer if found, other wise it will return NULL
 */

char *txtLoaderReadLineC(TxtFileLoader *txtFileLoader, int lineIndex) {

    if (txtFileLoader == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return NULL;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "loader", "text file loader");
        exit(NULL_POINTER);
#endif
    }

    txtLoaderOpenFile(txtFileLoader, "r");

    char c;
    int currentIndex = 0;

    while (currentIndex != lineIndex && (c = (char) fgetc(txtFileLoader->fileP)) != EOF) {

        if (c == '\n')
            currentIndex++;

    }


    if (currentIndex != lineIndex && c == EOF) {
        fclose(txtFileLoader->fileP);
        return NULL;
    }

    String *lineString = stringInitialization(5);
    while ((c = (char) fgetc(txtFileLoader->fileP)) != EOF && c != '\n')
        stringAppendChar(lineString, c);

    char *charLine = stringToCharArray(lineString);
    destroyString(lineString);


    fclose(txtFileLoader->fileP);
    return charLine;

}


/** This function will take a char array,
 * then it will write the char array to the file.
 *
 * Note: the file will be cleared before writing the new data.
 *
 * @param txtFileLoader the text file loader pointer
 * @param data the char array pointer
 */

void txtLoaderWriteC(TxtFileLoader *txtFileLoader, char *data) {

    if (txtFileLoader == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "loader", "text file loader");
        exit(NULL_POINTER);
#endif
    } else if (data == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = INVALID_ARG;
        return;
#else
        fprintf(stderr, INVALID_ARG_MESSAGE, "data char array", "text file loader");
        exit(INVALID_ARG);
#endif
    }


    txtLoaderOpenFile(txtFileLoader, "w");

    fprintf(txtFileLoader->fileP, "%s", data);

    fclose(txtFileLoader->fileP);

}


/** This function will take a string,
 * then it will write the string to the file.
 *
 * Note: the file will be cleared before writing the new data.
 *
 * @param txtFileLoader
 * @param data
 */

void txtLoaderWriteS(TxtFileLoader *txtFileLoader, String *data) {

    if (txtFileLoader == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "loader", "text file loader");
        exit(NULL_POINTER);
#endif
    } else if (data == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = INVALID_ARG;
        return;
#else
        fprintf(stderr, INVALID_ARG_MESSAGE, "data string", "text file loader");
        exit(INVALID_ARG);
#endif
    }

    txtLoaderOpenFile(txtFileLoader, "w");

    fprintf(txtFileLoader->fileP, "%s", data->string);

    fclose(txtFileLoader->fileP);

}


/** This function will take a char array,
 * then it will append the char array at the end of the file.
 *
 * @param txtFileLoader the text file loader pointer
 * @param data the char array pointer
 */

void txtLoaderAppendC(TxtFileLoader *txtFileLoader, char *data) {

    if (txtFileLoader == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "loader", "text file loader");
        exit(NULL_POINTER);
#endif
    } else if (data == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = INVALID_ARG;
        return;
#else
        fprintf(stderr, INVALID_ARG_MESSAGE, "data char array", "text file loader");
        exit(INVALID_ARG);
#endif
    }

    txtLoaderOpenFile(txtFileLoader, "a");

    fprintf(txtFileLoader->fileP, "%s", data);

    fclose(txtFileLoader->fileP);

}


/** This function will take a string,
 * then it will append the string at the end of the file.
 *
 * @param txtFileLoader
 * @param data
 */

void txtLoaderAppendS(TxtFileLoader *txtFileLoader, String *data) {

    if (txtFileLoader == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "loader", "text file loader");
        exit(NULL_POINTER);
#endif
    } else if (data == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = INVALID_ARG;
        return;
#else
        fprintf(stderr, INVALID_ARG_MESSAGE, "data string", "text file loader");
        exit(INVALID_ARG);
#endif
    }

    txtLoaderOpenFile(txtFileLoader, "a");
    fprintf(txtFileLoader->fileP, "%s", data->string);

    fclose(txtFileLoader->fileP);

}


/** This function will take a vector of char arrays,
 * then it will append the char arrays at the end of the file.
 *
 * @param txtFileLoader the text file loader pointer
 * @param newLines the new lines vector pointer
 */

void txtLoaderAppendAllC(TxtFileLoader *txtFileLoader, Vector *newLines) {

    if (txtFileLoader == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "loader", "text file loader");
        exit(NULL_POINTER);
#endif
    } else if (newLines == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = INVALID_ARG;
        return;
#else
        fprintf(stderr, INVALID_ARG_MESSAGE, "new lines vector", "text file loader");
        exit(INVALID_ARG);
#endif
    }

    txtLoaderOpenFile(txtFileLoader, "a");
    for (int i = 0; i < vectorGetLength(newLines); i++)
        fprintf(txtFileLoader->fileP, "%s\n", (char *) vectorGet(newLines, i));


    fclose(txtFileLoader->fileP);

}


/** This function will take a vector of strings,
 * then it will append the strings at the end of the file.
 *
 * @param txtFileLoader the text file loader pointer
 * @param newLines the new lines vector pointer
 */

void txtLoaderAppendAllS(TxtFileLoader *txtFileLoader, Vector *newLines) {

    if (txtFileLoader == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "loader", "text file loader");
        exit(NULL_POINTER);
#endif
    } else if (newLines == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = INVALID_ARG;
        return;
#else
        fprintf(stderr, INVALID_ARG_MESSAGE, "new lines vector", "text file loader");
        exit(INVALID_ARG);
#endif
    }

    txtLoaderOpenFile(txtFileLoader, "a");
    for (int i = 0; i < vectorGetLength(newLines); i++)
        fprintf(txtFileLoader->fileP, "%s\n", ((String *) vectorGet(newLines, i))->string);


    fclose(txtFileLoader->fileP);

}


/** This function will take a char array and an index,
 * then it will append the passed char array at the end of the line at the provided index.
 *
 * @param txtFileLoader the text file loader pointer
 * @param lineToAppend the char array pointer of the line to be appended
 * @param index the index of the file that the char array will be appended to
 */

void txtLoaderAppendToLineC(TxtFileLoader *txtFileLoader, char *lineToAppend, int index) {

    if (txtFileLoader == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "loader", "text file loader");
        exit(NULL_POINTER);
#endif
    } else if (lineToAppend == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = INVALID_ARG;
        return;
#else
        fprintf(stderr, INVALID_ARG_MESSAGE, "new line to append char array", "text file loader");
        exit(INVALID_ARG);
#endif
    }

    Vector *linesVector = txtLoaderReadFileLines(txtFileLoader);
    if (index < 0 || index >= vectorGetLength(linesVector)) {
        destroyVector(linesVector);
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = INVALID_ARG;
        return;
#else
        fprintf(stderr, INVALID_ARG_MESSAGE, "new line to append index", "text file loader");
        exit(INVALID_ARG);
#endif
    }

    stringAppendC(vectorGet(linesVector, index), lineToAppend);

    txtLoaderOpenFile(txtFileLoader, "w");

    for (int i = 0; i < vectorGetLength(linesVector); i++)
        fprintf(txtFileLoader->fileP, "%s%c", ((String *) vectorGet(linesVector, i))->string,
                i != vectorGetLength(linesVector) - 1 ? '\n' : '\0');


    destroyVector(linesVector);

    fclose(txtFileLoader->fileP);

}


/** This function will take a string and an index,
 * then it will append the passed string at the end of the line at the provided index.
 *
 * @param txtFileLoader the text file loader pointer
 * @param stringToAppend the string pointer of the line to be appended
 * @param index the index of the file that the string will be appended to
 */

void txtLoaderAppendToLineS(TxtFileLoader *txtFileLoader, String *stringToAppend, int index) {

    if (txtFileLoader == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "loader", "text file loader");
        exit(NULL_POINTER);
#endif
    } else if (stringToAppend == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = INVALID_ARG;
        return;
#else
        fprintf(stderr, INVALID_ARG_MESSAGE, "new string to append", "text file loader");
        exit(INVALID_ARG);
#endif
    }

    Vector *linesVector = txtLoaderReadFileLines(txtFileLoader);
    if (index < 0 || index >= vectorGetLength(linesVector)) {
        destroyVector(linesVector);
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = INVALID_ARG;
        return;
#else
        fprintf(stderr, INVALID_ARG_MESSAGE, "new string to append index", "text file loader");
        exit(INVALID_ARG);
#endif
    }

    stringAppendS(vectorGet(linesVector, index), stringToAppend);

    txtLoaderOpenFile(txtFileLoader, "w");

    for (int i = 0; i < vectorGetLength(linesVector); i++)
        fprintf(txtFileLoader->fileP, "%s%c", ((String *) vectorGet(linesVector, i))->string,
                i != vectorGetLength(linesVector) - 1 ? '\n' : '\0');


    destroyVector(linesVector);

    fclose(txtFileLoader->fileP);

}


/** This function will take a char array and index,
 * then it will insert the passed char array at the provided index.
 *
 * @param txtFileLoader the text file loader pointer
 * @param line the char array pointer of the new line
 * @param index the index that the new line will be insert to
 */

void txtLoaderAddLineC(TxtFileLoader *txtFileLoader, char *line, int index) {

    if (txtFileLoader == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "loader", "text file loader");
        exit(NULL_POINTER);
#endif
    } else if (line == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = INVALID_ARG;
        return;
#else
        fprintf(stderr, INVALID_ARG_MESSAGE, "new line char array", "text file loader");
        exit(INVALID_ARG);
#endif
    }

    Vector *linesVector = txtLoaderReadFileLines(txtFileLoader);
    if (index < 0 || index >= vectorGetLength(linesVector)) {
        destroyVector(linesVector);
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = INVALID_ARG;
        return;
#else
        fprintf(stderr, INVALID_ARG_MESSAGE, "new line index", "text file loader");
        exit(INVALID_ARG);
#endif
    }

    String *newLineString = stringInitialization(10);
    stringChangeStringC(newLineString, line);

    vectorAddAtIndex(linesVector, newLineString, index);

    txtLoaderOpenFile(txtFileLoader, "w");

    for (int i = 0; i < vectorGetLength(linesVector); i++)
        fprintf(txtFileLoader->fileP, "%s\n", ((String *) vectorGet(linesVector, i))->string);


    destroyVector(linesVector);

    fclose(txtFileLoader->fileP);

}


/** This function will take a string and index,
 * then it will insert the passed string at the provided index.
 *
 * @param txtFileLoader the text file loader pointer
 * @param line the string pointer of the new line
 * @param index the index that the new line will be insert to
 */


void txtLoaderAddLineS(TxtFileLoader *txtFileLoader, String *line, int index) {

    if (txtFileLoader == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "loader", "text file loader");
        exit(NULL_POINTER);
#endif
    } else if (line == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = INVALID_ARG;
        return;
#else
        fprintf(stderr, INVALID_ARG_MESSAGE, "new string", "text file loader");
        exit(INVALID_ARG);
#endif
    }

    Vector *linesVector = txtLoaderReadFileLines(txtFileLoader);
    if (index < 0 || index >= vectorGetLength(linesVector)) {
        destroyVector(linesVector);
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = INVALID_ARG;
        return;
#else
        fprintf(stderr, INVALID_ARG_MESSAGE, "new line index", "text file loader");
        exit(INVALID_ARG);
#endif
    }

    vectorAddAtIndex(linesVector, line, index);

    txtLoaderOpenFile(txtFileLoader, "w");

    for (int i = 0; i < vectorGetLength(linesVector); i++)
        fprintf(txtFileLoader->fileP, "%s\n", ((String *) vectorGet(linesVector, i))->string);


    vectorRemoveAtIndexWtFr(linesVector, index);
    destroyVector(linesVector);

    fclose(txtFileLoader->fileP);

}


/** This function will take a vector of char arrays and index,
 * then it will insert the passed vector at the provided index.
 *
 * @param txtFileLoader the text file loader pointer
 * @param newLines the new lines vector pointer
 * @param index the index that the new lines will be inserted in
 */

void txtLoaderAddAllC(TxtFileLoader *txtFileLoader, Vector *newLines, int index) {

    if (txtFileLoader == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "loader", "text file loader");
        exit(NULL_POINTER);
#endif
    } else if (newLines == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = INVALID_ARG;
        return;
#else
        fprintf(stderr, INVALID_ARG_MESSAGE, "new lines vector", "text file loader");
        exit(INVALID_ARG);
#endif
    }

    Vector *linesVector = txtLoaderReadFileLines(txtFileLoader);
    if (index < 0 || index >= vectorGetLength(linesVector)) {
        destroyVector(linesVector);
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = INVALID_ARG;
        return;
#else
        fprintf(stderr, INVALID_ARG_MESSAGE, "new lines index", "text file loader");
        exit(INVALID_ARG);
#endif
    }

    for (int i = vectorGetLength(newLines) - 1; i >= 0; i--) {

        String *tempLineString = stringInitialization(10);
        stringChangeStringC(tempLineString, vectorGet(newLines, i));
        vectorAddAtIndex(linesVector, tempLineString, index);

    }

    txtLoaderOpenFile(txtFileLoader, "w");

    for (int i = 0; i < vectorGetLength(linesVector); i++) {

        fprintf(txtFileLoader->fileP, "%s%c", ((String *) vectorGet(linesVector, i))->string,
                i != vectorGetLength(linesVector) - 1 ? '\n' : '\0');

    }


    destroyVector(linesVector);

    fclose(txtFileLoader->fileP);

}


/** This function will take a vector of strings and index,
 * then it will insert the passed vector at the provided index.
 *
 * @param txtFileLoader the text file loader pointer
 * @param newLines the new lines vector pointer
 * @param index the index that the new lines will be inserted in
 */

void txtLoaderAddAllS(TxtFileLoader *txtFileLoader, Vector *newLines, int index) {

    if (txtFileLoader == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "loader", "text file loader");
        exit(NULL_POINTER);
#endif
    } else if (newLines == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = INVALID_ARG;
        return;
#else
        fprintf(stderr, INVALID_ARG_MESSAGE, "new lines vector", "text file loader");
        exit(INVALID_ARG);
#endif
    }

    Vector *linesVector = txtLoaderReadFileLines(txtFileLoader);
    if (index < 0 || index >= vectorGetLength(linesVector)) {
        destroyVector(linesVector);
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = INVALID_ARG;
        return;
#else
        fprintf(stderr, INVALID_ARG_MESSAGE, "new lines index", "text file loader");
        exit(INVALID_ARG);
#endif
    }

    for (int i = vectorGetLength(newLines) - 1; i >= 0; i--)
        vectorAddAtIndex(linesVector, vectorGet(newLines, i), index);

    txtLoaderOpenFile(txtFileLoader, "w");

    for (int i = 0; i < vectorGetLength(linesVector); i++) {

        fprintf(txtFileLoader->fileP, "%s%c", ((String *) vectorGet(linesVector, i))->string,
                i != vectorGetLength(linesVector) - 1 ? '\n' : '\0');


    }


    for (int i = 0; i < vectorGetLength(newLines); i++)
        vectorRemoveAtIndexWtFr(linesVector, index);

    destroyVector(linesVector);

    fclose(txtFileLoader->fileP);

}


/** This function will take a char array and an index,
 * then it will update the line in the provided index with the passed char array.
 *
 * @param txtFileLoader the text file loader pointer
 * @param line the new line char array
 * @param index the index of the line that will be updated
 */

void txtLoaderUpdateLineC(TxtFileLoader *txtFileLoader, char *line, int index) {

    if (txtFileLoader == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "loader", "text file loader");
        exit(NULL_POINTER);
#endif
    } else if (line == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = INVALID_ARG;
        return;
#else
        fprintf(stderr, INVALID_ARG_MESSAGE, "new line char array", "text file loader");
        exit(INVALID_ARG);
#endif
    }

    Vector *linesVector = txtLoaderReadFileLines(txtFileLoader);
    if (index < 0 || index >= vectorGetLength(linesVector)) {
        destroyVector(linesVector);
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = INVALID_ARG;
        return;
#else
        fprintf(stderr, INVALID_ARG_MESSAGE, "new line index", "text file loader");
        exit(INVALID_ARG);
#endif
    }

    stringChangeStringC(vectorGet(linesVector, index), line);

    txtLoaderOpenFile(txtFileLoader, "w");

    for (int i = 0; i < vectorGetLength(linesVector); i++)
        fprintf(txtFileLoader->fileP, "%s%c", ((String *) vectorGet(linesVector, i))->string,
                i != vectorGetLength(linesVector) - 1 ? '\n' : '\0');


    destroyVector(linesVector);

    fclose(txtFileLoader->fileP);

}


/** This function will take a string and an index,
 * then it will update the line in the provided index with the passed string.
 *
 * @param txtFileLoader the text file loader pointer
 * @param line the new line string
 * @param index the index of the line that will be updated
 */

void txtLoaderUpdateLineS(TxtFileLoader *txtFileLoader, String *line, int index) {

    if (txtFileLoader == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "loader", "text file loader");
        exit(NULL_POINTER);
#endif
    } else if (line == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = INVALID_ARG;
        return;
#else
        fprintf(stderr, INVALID_ARG_MESSAGE, "new string", "text file loader");
        exit(INVALID_ARG);
#endif
    }

    Vector *linesVector = txtLoaderReadFileLines(txtFileLoader);
    if (index < 0 || index >= vectorGetLength(linesVector)) {
        destroyVector(linesVector);
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = INVALID_ARG;
        return;
#else
        fprintf(stderr, INVALID_ARG_MESSAGE, "new line index", "text file loader");
        exit(INVALID_ARG);
#endif
    }

    stringChangeStringS(vectorGet(linesVector, index), line);

    txtLoaderOpenFile(txtFileLoader, "w");

    for (int i = 0; i < vectorGetLength(linesVector); i++)
        fprintf(txtFileLoader->fileP, "%s%c", ((String *) vectorGet(linesVector, i))->string,
                i != vectorGetLength(linesVector) - 1 ? '\n' : '\0');


    destroyVector(linesVector);

    fclose(txtFileLoader->fileP);

}


/** This function will take an index,
 * then it will remove the line at the provided index.
 *
 * @param txtFileLoader the text file loader pointer
 * @param index the index of the line that will be removed
 */

void txtLoaderRemoveLine(TxtFileLoader *txtFileLoader, int index) {

    if (txtFileLoader == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "loader", "text file loader");
        exit(NULL_POINTER);
#endif
    }

    Vector *linesVector = txtLoaderReadFileLines(txtFileLoader);
    if (index < 0 || index >= vectorGetLength(linesVector)) {
        destroyVector(linesVector);
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = INVALID_ARG;
        return;
#else
        fprintf(stderr, INVALID_ARG_MESSAGE, "new line index", "text file loader");
        exit(INVALID_ARG);
#endif
    }

    vectorRemoveAtIndex(linesVector, index);

    txtLoaderOpenFile(txtFileLoader, "w");

    for (int i = 0; i < vectorGetLength(linesVector); i++)
        fprintf(txtFileLoader->fileP, "%s%c", ((String *) vectorGet(linesVector, i))->string,
                i != vectorGetLength(linesVector) - 1 ? '\n' : '\0');


    destroyVector(linesVector);

    fclose(txtFileLoader->fileP);

}


/** This function will clear the text file.
 *
 * @param txtFileLoader the text file loader pointer
 */

void txtLoaderClearFile(TxtFileLoader *txtFileLoader) {

    if (txtFileLoader == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "loader", "text file loader");
        exit(NULL_POINTER);
#endif
    }


    txtLoaderOpenFile(txtFileLoader, "w");

    fflush(txtFileLoader->fileP);

    fclose(txtFileLoader->fileP);

}


/** This function will change the file direction of text file loader.
 *
 * @param txtFileLoader the text file loader pointer
 * @param newFileDir the new direction char array pointer
 */

void txtLoaderChangeFile(TxtFileLoader *txtFileLoader, char *newFileDir) {

    free(txtFileLoader->dir);

    txtFileLoader->dir = (char *) malloc(sizeof(char) * (strlen(newFileDir) + 1));
    if (txtFileLoader->dir == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = FAILED_ALLOCATION;
        return;
#else
        fprintf(stderr, FAILED_ALLOCATION_MESSAGE, "file direction", "text file loader");
        exit(FAILED_ALLOCATION);
#endif
    }

    txtFileLoader->dir = strcpy(txtFileLoader->dir, newFileDir);
    if (txtFileLoader->dir == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = FAILED_COPY;
        return;
#else
        fprintf(stderr, FAILED_COPY_MESSAGE, "file direction", "text file loader");
        exit(FAILED_COPY);
#endif
    }

}


/** This function will destroy and free the passed text file loader.
 *
 * @param txtFileLoader the text file loader pointer
 */

void destroyTxtFileLoader(void *txtFileLoader) {

    if (txtFileLoader == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "loader", "text file loader");
        exit(NULL_POINTER);
#endif
    }

    free( ((TxtFileLoader *) txtFileLoader)->dir );
    free(txtFileLoader);

}


/** This function will take the initial length of the vector, and the freeing and comparator functions as a parameter,
 * then it will initialize a new vector in the memory and set it's fields then return it.
 *
 * @param initialLength the initial length of the vector.
 * @param freeFun the function address that will be called to free the vector items.
 * @param comparator the comparator function address, that will be called to compare two items in the vector
 * @return it will return the initialized vector pointer
 */

Vector *
vectorInitialization(int initialLength, void (*freeFun)(void *), int (*comparator)(const void *, const void *)) {
    if (freeFun == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = INVALID_ARG;
        return NULL;
#else
        fprintf(stderr, INVALID_ARG_MESSAGE, "free function", "vector data structure");
        exit(INVALID_ARG);
#endif

    } else if (initialLength <= 0) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = INVALID_ARG;
        return NULL;
#else
        fprintf(stderr, INVALID_ARG_MESSAGE, "initial length", "vector data structure");
        exit(INVALID_ARG);
#endif

    }

    Vector *list = (Vector *) malloc(sizeof(Vector));
    if (list == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = FAILED_ALLOCATION;
        return NULL;
#else
        fprintf(stderr, FAILED_ALLOCATION_MESSAGE, "data structure", "vector data structure");
        exit(FAILED_ALLOCATION);
#endif

    }

    list->arr = (void **) malloc(sizeof(void *) * initialLength);
    if (list->arr == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = FAILED_ALLOCATION;
        return NULL;
#else
        fprintf(stderr, FAILED_ALLOCATION_MESSAGE, "items memory", "vector data structure");
        exit(FAILED_ALLOCATION);
#endif

    }

    list->length = initialLength > 0 ? initialLength : 1;
    list->count = 0;
    list->freeItem = freeFun;
    list->comparator = comparator;

    return list;
}


/** This function will take the vector address, and the item address as a parameters,
 * then it will put the item in the end of the vector.
 *
 * @param list the vector address
 * @param item the item address
 */

void vectorAdd(Vector *list, void *item) {

    if (list == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "vector", "vector data structure");
        exit(NULL_POINTER);
#endif

    } else if (item == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = INVALID_ARG;
        return;
#else
        fprintf(stderr, INVALID_ARG_MESSAGE, "item pointer", "vector data structure");
        exit(INVALID_ARG);
#endif

    }

    if (list->count == list->length) {
        list->length *= 2;

        list->arr = (void **) realloc(list->arr, sizeof(void *) * list->length);
        if (list->arr == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
            ERROR_TEST->errorCode = FAILED_REALLOCATION;
            return;
#else
            fprintf(stderr, FAILED_REALLOCATION_MESSAGE, "items memory", "vector data structure");
            exit(FAILED_REALLOCATION);
#endif

        }

    }


    list->arr[list->count++] = item;

}


/** This function will take the vector address, and the item address as a parameters,
 * then it will put the new item in provided index.
 *
 * @param list the vector address
 * @param item the item address
 * @param index the index of the new item
 */

void vectorAddAtIndex(Vector *list, void *item, int index) {

    if (list == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "vector", "vector data structure");
        exit(NULL_POINTER);
#endif

    } else if (item == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = INVALID_ARG;
        return;
#else
        fprintf(stderr, INVALID_ARG_MESSAGE, "item pointer", "vector data structure");
        exit(INVALID_ARG);
#endif

    } else if (index < 0 || index >= vectorGetLength(list)) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = OUT_OF_RANGE;
        return;
#else
        fprintf(stderr, OUT_OF_RANGE_MESSAGE, "vector data structure");
        exit(OUT_OF_RANGE);
#endif

    }

    if (list->count == list->length) {
        list->length *= 2;

        list->arr = (void **) realloc(list->arr, sizeof(void *) * list->length);
        if (list->arr == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
            ERROR_TEST->errorCode = FAILED_REALLOCATION;
            return;
#else
            fprintf(stderr, FAILED_REALLOCATION_MESSAGE, "items memory", "vector data structure");
            exit(FAILED_REALLOCATION);
#endif

        }

    }


    for (int i = list->count++; i > index; i--)
        list->arr[i] = list->arr[i - 1];


    list->arr[index] = item;

}


/** This function will take the vector address, the items array, and the length of items array as a parameters,
 * then it will copy the items array into the vector.
 *
 * @param list the vector address
 * @param array the array address that will be inserted in the vector
 * @param arrayLength the length of the array that will be added
 */

void vectorAddAll(Vector *list, void **array, int arrayLength) {
    if (list == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "vector", "vector data structure");
        exit(NULL_POINTER);
#endif

    } else if (array == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = INVALID_ARG;
        return;
#else
        fprintf(stderr, INVALID_ARG_MESSAGE, "items array", "vector data structure");
        exit(INVALID_ARG);
#endif

    }

    for (int i = 0; i < arrayLength; i++)
        vectorAdd(list, array[i]);

}


/** This function will take the vector as a parameter,
 * then it will remove the last item in the vector.
 *
 * Note: if the vector is empty then the program will be terminated.
 *
 * @param list the vector address
 */

void vectorRemove(Vector *list) {
    if (list == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "vector", "vector data structure");
        exit(NULL_POINTER);
#endif

    } else if (vectorIsEmpty(list)) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = EMPTY_DATA_STRUCTURE;
        return;
#else
        fprintf(stderr, EMPTY_DATA_STRUCTURE_MESSAGE, "vector data structure");
        exit(EMPTY_DATA_STRUCTURE);
#endif

    }

    list->freeItem(list->arr[vectorGetLength(list) - 1]);

    list->count--;

}


/** This function will take the vector as a parameter,
 * then it will remove the last item in the vector, without freeing the item.
 *
 * Note: if the vector is empty then the program will be terminated.
 *
 * @param list the vector address
 * @return it will return the deleted item pointer
 */

void *vectorRemoveWtFr(Vector *list) {
    if (list == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return NULL;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "vector", "vector data structure");
        exit(NULL_POINTER);
#endif

    } else if (vectorIsEmpty(list)) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = EMPTY_DATA_STRUCTURE;
        return NULL;
#else
        fprintf(stderr, EMPTY_DATA_STRUCTURE_MESSAGE, "vector data structure");
        exit(EMPTY_DATA_STRUCTURE);
#endif

    }

    return list->arr[--list->count];

}


/** This function will take the vector address, and the index as a parameters,
 * then it will remove the item in the given index from the vector.
 *
 * Note: if the index is out of the vector range then the program will be terminated.
 *
 * @param list the vector address
 * @param index the index of the item that will be deleted
 */

void vectorRemoveAtIndex(Vector *list, int index) {
    if (list == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "vector", "vector data structure");
        exit(NULL_POINTER);
#endif

    } else if (index < 0 || index >= vectorGetLength(list)) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = OUT_OF_RANGE;
        return;
#else
        fprintf(stderr, OUT_OF_RANGE_MESSAGE, "vector data structure");
        exit(OUT_OF_RANGE);
#endif

    }

    list->freeItem(list->arr[index]);
    list->count--;

    for (int i = index; i < list->count; i++) //this loop will shift the items to the left to delete the index.
        list->arr[i] = list->arr[i + 1];


}


/** This function will take the vector address, and the index as a parameters,
 * then it will remove the item in the given index from the vector, without freeing the item.
 *
 * Note: if the index is out of the vector range then the program will be terminated.
 *
 * @param list the vector address
 * @param index the index of the item that will be deleted
 * @return it will return the deleted item pointer
 */

void *vectorRemoveAtIndexWtFr(Vector *list, int index) {
    if (list == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return NULL;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "vector", "vector data structure");
        exit(NULL_POINTER);
#endif

    } else if (index < 0 || index >= vectorGetLength(list)) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = OUT_OF_RANGE;
        return NULL;
#else
        fprintf(stderr, OUT_OF_RANGE_MESSAGE, "vector data structure");
        exit(OUT_OF_RANGE);
#endif

    }

    void *itemToReturn = list->arr[index];
    list->count--;

    for (int i = index; i < list->count; i++) //this loop will shift the items to the left to delete the index.
        list->arr[i] = list->arr[i + 1];

    return itemToReturn;

}


/** This function will take the vector address, and the item address as a parameters,
 * then it will return one (1) if the item is in the vector,
 * other wise it will return zero (0).
 *
 * Note: comparator function should return zero (0) when the two items are equal.
 *
 * Note: this function will not free the passed item.
 *
 * @param list the vector address
 * @param item the item that will be compared by address
 * @return it will return one if the item is in the vector other wise it will return zero
 */

int vectorContains(Vector *list, void *item) {

    if (list == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return 0;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "vector", "vector data structure");
        exit(NULL_POINTER);
#endif

    } else if (item == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = INVALID_ARG;
        return 0;
#else
        fprintf(stderr, INVALID_ARG_MESSAGE, "item pointer", "vector data structure");
        exit(INVALID_ARG);
#endif

    } else if (list->comparator == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return 0;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "comparator function", "vector data structure");
        exit(NULL_POINTER);
#endif

    }

    for (int i = 0; i < list->count; i++) {

        if (list->comparator(item, list->arr[i]) == 0)
            return 1;

    }

    return 0;

}


/** This function will take the vector address, and the item address as a parameters,
 * then it will return the index of the item if found,
 * other wise it will return minus one (-1).
 *
 * Note: comparator function should return zero (0) when the two items are equal.
 *
 * Note: this function will not free the passed item.
 *
 * @param list the vector address
 * @param item the item address that will be searching for
 * @return it will return the item address if found, other wise it will return minus one
 */

int vectorGetIndex(Vector *list, void *item) {

    if (list == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return -1;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "vector", "vector data structure");
        exit(NULL_POINTER);
#endif

    } else if (item == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = INVALID_ARG;
        return -1;
#else
        fprintf(stderr, INVALID_ARG_MESSAGE, "item pointer", "vector data structure");
        exit(INVALID_ARG);
#endif

    } else if (list->comparator == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return -1;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "comparator function", "vector data structure");
        exit(NULL_POINTER);
#endif

    }

    for (int i = 0; i < list->count; i++) {

        if (list->comparator(list->arr[i], item) == 0)
            return i;

    }

    return -1;

}


/** This function will take the vector address, and the item address as a parameters,
 * then it will return the last index of the item if found,
 * other wise it will return minus one (-1).
 *
 * Note: comparator function should return zero (0) when the two items are equal.
 *
 * Note: this function will not free the passed item.
 *
 * @param list the vector address
 * @param item the item address that will be searching for
 * @return it will return the item address if found, other wise it will return minus one
 */

int vectorGetLastIndex(Vector *list, void *item) {

    if (list == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return -1;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "vector", "vector data structure");
        exit(NULL_POINTER);
#endif

    } else if (item == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = INVALID_ARG;
        return -1;
#else
        fprintf(stderr, INVALID_ARG_MESSAGE, "item pointer", "vector data structure");
        exit(INVALID_ARG);
#endif

    } else if (list->comparator == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return -1;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "comparator function", "vector data structure");
        exit(NULL_POINTER);
#endif

    }

    for (int i = list->count - 1; i >= 0; i--) {

        if (list->comparator(list->arr[i], item) == 0)
            return i;

    }

    return -1;

}


/** This function will take the vector address, and the index as a parameters,
 * then it will return the item at the given index.
 *
 * Note: if the index is out of the vector range then the program will be terminated.
 *
 * @param list the vector address
 * @param index the item index
 * @return it will return a void pointer to the item
 */

void *vectorGet(Vector *list, int index) {
    if (list == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return NULL;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "vector", "vector data structure");
        exit(NULL_POINTER);
#endif

    } else if (index < 0 || index >= vectorGetLength(list)) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = OUT_OF_RANGE;
        return NULL;
#else
        fprintf(stderr, OUT_OF_RANGE_MESSAGE, "vector data structure");
        exit(OUT_OF_RANGE);
#endif

    }

    return list->arr[index];

}


/** This function will take the vector address as a parameter,
 * then it will return a void pointer array that consist of the vector elements.
 *
 * @param list the vector address
 * @return it will return a double void pointer to an array that has a copy of the items
 */

void **vectorToArray(Vector *list) {

    if (list == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return NULL;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "vector", "vector data structure");
        exit(NULL_POINTER);
#endif

    }

    void **array = (void **) malloc(sizeof(void *) * vectorGetLength(list));
    if (array == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = FAILED_ALLOCATION;
        return NULL;
#else
        fprintf(stderr, FAILED_ALLOCATION_MESSAGE, "to array", "vector data structure");
        exit(FAILED_ALLOCATION);
#endif

    }

    for (int i = 0; i < vectorGetLength(list); i++)
        array[i] = list->arr[i];

    return array;

}


/** This function will take the vector address, the start index, and the end index as a parameters,
 * then it will return a void pointer array that consist of the items at the start index to end index.
 *
 * @param list the vector address
 * @param start the start index
 * @param end the end index
 * @return it will return a double void pointer that has a copy of the items in the vector
 */

void **vectorToSubArray(Vector *list, int start, int end) {

    if (list == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return NULL;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "vector", "vector data structure");
        exit(NULL_POINTER);
#endif

    } else if (start < 0 || end > vectorGetLength(list) || start > end) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = OUT_OF_RANGE;
        return NULL;
#else
        fprintf(stderr, OUT_OF_RANGE_MESSAGE, "vector data structure");
        exit(OUT_OF_RANGE);
#endif

    }

    void **array = (void **) malloc(sizeof(void *) * (end - start + 1));
    if (array == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = FAILED_ALLOCATION;
        return NULL;
#else
        fprintf(stderr, FAILED_ALLOCATION_MESSAGE, "to array", "vector data structure");
        exit(FAILED_ALLOCATION);
#endif

    }

    for (int i = start; i <= end; i++)
        array[i - start] = list->arr[i];


    return array;

}


/** This function will take the vector address, and the sort comparator function as a parameter,
 * then it will sort the vector using qsort algorithm.
 *
 * Note: the pointer will be sent to the sort comparator function will be a double void pointer (void **) of an vector item.
 *
 * Example of comparator function if the items are integers:
 *
 * int comp(const void *item1, const void *item2) { return *(int *)(*(void **)item1)->item - *(int *)(*(void **)item2)->item; }
 *
 * @param list the vector address
 * @param sortComp the sort comparator function address
 */

void vectorSort(Vector *list, int (*sortComp)(const void *, const void *)) {
    if (list == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "vector", "vector data structure");
        exit(NULL_POINTER);
#endif

    } else if (sortComp == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = INVALID_ARG;
        return;
#else
        fprintf(stderr, INVALID_ARG_MESSAGE, "sort comparator function", "vector data structure");
        exit(INVALID_ARG);
#endif

    }

    qsort(list->arr, vectorGetLength(list), sizeof(void *), sortComp);

}


/** This function will take the vector address as a parameter,
 * then it will return the length of the vector.
 *
 * @param list the vector address
 * @return it will return the number of items in the vector
 */

int vectorGetLength(Vector *list) {

    if (list == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return -1;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "vector", "vector data structure");
        exit(NULL_POINTER);
#endif

    }

    return list->count;

}


/** This function will take the vector address as a parameter,
 * then it will return one if the vector is empty,
 * other wise it will return 0.
 *
 * @param list the vector address
 * @return it will return one if the vector is empty, other wise it will return zero
 */

int vectorIsEmpty(Vector *list) {

    if (list == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return -1;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "vector", "vector data structure");
        exit(NULL_POINTER);
#endif

    }

    return list->count == 0;

}


/** This function will take the vector address, and the print function address as a parameter,
 * then it will call the print function and send every item in the vector to be printed.
 *
 * @param list the vector address
 * @param printFun the print function address
 */

void printVector(Vector *list, void (*printFun)(const void *)) {
    if (list == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "vector", "vector data structure");
        exit(NULL_POINTER);
#endif

    } else if (printFun == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = INVALID_ARG;
        return;
#else
        fprintf(stderr, INVALID_ARG_MESSAGE, "print function pointer", "vector data structure");
        exit(INVALID_ARG);
#endif

    }

    for (int i = 0; i < vectorGetLength(list); i++)
        printFun(list->arr[i]);


}


/** This function will take the vector address as a parameter,
 * then it will destroy and free all the vector items.
 *
 * Note: the function will just clear the vector, but it will not destroy the vector.
 *
 * @param list the vector address
 */

void clearVector(Vector *list) {

    if (list == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "vector", "vector data structure");
        exit(NULL_POINTER);
#endif

    }

    for (int i = 0; i < vectorGetLength(list); i++)
        list->freeItem(list->arr[i]);


    list->count = 0;

}


/** This function will take the vector address as a parameter,
 * then it will destroy and free the vector and all it's items.
 *
 * @param list the vector address
 */

void destroyVector(void *list) {

    if (list == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "vector", "vector data structure");
        exit(NULL_POINTER);
#endif

    }

    clearVector(list);
    free(((Vector *) list)->arr);
    free(list);

}

/** This function will take the initial length of the string as a parameter,
 * then it will initialize a new String pointer and return it.
 *
 * @param initialLength the string initial length
 * @return it will return the initialized string
 */

String *stringInitialization(int initialLength) {
    if (initialLength <= 0) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = INVALID_ARG;
        return NULL;
#else
        fprintf(stderr, INVALID_ARG_MESSAGE, "initial length", "string data structure");
        exit(INVALID_ARG);
#endif

    }

    String *myString = (String *) malloc(sizeof(String));
    if (myString == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = FAILED_ALLOCATION;
        return NULL;
#else
        fprintf(stderr, FAILED_ALLOCATION_MESSAGE, "string", "string data structure");
        exit(FAILED_ALLOCATION);
#endif

    }

    myString->string = (char *) malloc(sizeof(char) * (initialLength + 1));
    if (myString->string == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = FAILED_ALLOCATION;
        return NULL;
#else
        fprintf(stderr, FAILED_ALLOCATION_MESSAGE, "string array", "string data structure");
        exit(FAILED_ALLOCATION);
#endif

    }

    myString->string[0] = '\0';
    myString->count = 0;
    myString->length = initialLength;

    return myString;
}


/** This function will take the string address, and the new character as a parameter,
 * then it will put the new character in the end of the string.
 *
 * @param string the string address
 * @param c the new character
 */

void stringAppendChar(String *string, char c) {
    if (string == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "string", "string data structure");
        exit(NULL_POINTER);
#endif

    }

    if (string->count == string->length) {
        string->length *= 2;
        string->string = realloc(string->string, sizeof(char) * (string->length + 1));
        if (string->string == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
            ERROR_TEST->errorCode = FAILED_REALLOCATION;
            return;
#else
            fprintf(stderr, FAILED_REALLOCATION_MESSAGE, "string array", "string data structure");
            exit(FAILED_REALLOCATION);
#endif

        }

    }

    string->string[string->count++] = c;
    string->string[string->count] = '\0';

}


/** This function will take the string address, index, and the new character as a parameters,
 * then it will put the new character in the given index.
 *
 * Note: if the index is out of the string range the program will terminate.
 *
 * @param string the string address
 * @param index the new character index
 * @param c the new character
 */

void stringAddChar(String *string, int index, char c) {
    if (string == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "string", "string data structure");
        exit(NULL_POINTER);
#endif

    } else if (string->count <= index || index < 0) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = OUT_OF_RANGE;
        return;
#else
        fprintf(stderr, OUT_OF_RANGE_MESSAGE, "string data structure");
        exit(OUT_OF_RANGE);
#endif

    }

    if (string->count == string->length) {

        string->length *= 2;
        string->string = (char *) realloc(string->string, sizeof(char) * (string->length + 1));

        if (string->string == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
            ERROR_TEST->errorCode = FAILED_REALLOCATION;
            return;
#else
            fprintf(stderr, FAILED_REALLOCATION_MESSAGE, "string char array", "string data structure");
            exit(FAILED_REALLOCATION);
#endif

        }

    }

    for (int i = string->count++; i > index; i--)
        string->string[i] = string->string[i - 1];

    string->string[index] = c;
    string->string[string->count] = '\0';

}


/** This function will take the string address, index, and the a character as a parameters,
 * then it will update the character at the provided index with the new passed character.
 *
 * Note: if the index is out of the string range the program will terminate.
 *
 * @param string the string address
 * @param index the character index
 * @param c the new character
 */

void stringUpdateChar(String *string, int index, char c) {

    if (string == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "string", "string data structure");
        exit(NULL_POINTER);
#endif

    } else if (string->count <= index || index < 0) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = OUT_OF_RANGE;
        return;
#else
        fprintf(stderr, OUT_OF_RANGE_MESSAGE, "string data structure");
        exit(OUT_OF_RANGE);
#endif

    }

    string->string[index] = c;

}


/** This function will take the string address, and the index as a parameter,
 * then it will remove the character in the given index.
 *
 * Note: if the index is out of the string range the program will terminate.
 *
 * @param string the string address
 * @param index the index of the char that will be removed
 */

void stringRemove(String *string, int index) {
    if (string == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "string", "string data structure");
        exit(NULL_POINTER);
#endif

    } else if (string->count <= index || index < 0) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = OUT_OF_RANGE;
        return;
#else
        fprintf(stderr, OUT_OF_RANGE_MESSAGE, "string data structure");
        exit(OUT_OF_RANGE);
#endif

    }

    for (int i = index; i < string->count; i++)
        string->string[i] = string->string[i + 1];

    string->count--;

}


/** This function will take the string address, and the new char array pointer as a parameters,
 * then it will add the new array of characters at the end of the original string.
 *
 * @param string the string address
 * @param charArr the char array address
 */

void stringAppendC(String *string, char *charArr) {
    if (string == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "string", "string data structure");
        exit(NULL_POINTER);
#endif

    } else if (charArr == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = INVALID_ARG;
        return;
#else
        fprintf(stderr, INVALID_ARG_MESSAGE, "char array pointer", "string data structure");
        exit(INVALID_ARG);
#endif

    }

    char *currentChar = charArr;
    while (*currentChar != '\0') {
        stringAppendChar(string, *currentChar);
        currentChar++;
    }

}


/** This function will take the string address, and the new string pointer array as a parameters,
 * then it will add the new string at the end of the original string.
 *
 * @param string the string address
 * @param newString the string pointer
 */

void stringAppendS(String *string, String *newString) {
    if (string == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "string", "string data structure");
        exit(NULL_POINTER);
#endif

    } else if (newString == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = INVALID_ARG;
        return;
#else
        fprintf(stderr, INVALID_ARG_MESSAGE, "string pointer", "string data structure");
        exit(INVALID_ARG);
#endif

    }

    char *currentChar = newString->string;
    while (*currentChar != '\0') {
        stringAppendChar(string, *currentChar);
        currentChar++;
    }

}


/** This function will take the string address, and the new char pointer array as a parameters,
 * then it will change the string to the new char pointer array.
 *
 * @param string the string address
 * @param newCharArr a char array address
 */

void stringChangeStringC(String *string, char *newCharArr) {
    if (string == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "string", "string data structure");
        exit(NULL_POINTER);
#endif

    } else if (newCharArr == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = INVALID_ARG;
        return;
#else
        fprintf(stderr, INVALID_ARG_MESSAGE, "new char array pointer", "string data structure");
        exit(INVALID_ARG);
#endif

    }

    string->count = 0;
    string->string[string->count] = '\0';

    while (*newCharArr != '\0')
        stringAppendChar(string, *newCharArr++);

}


/** This function will take string address, and the the new string address as a parameters,
 * then it will change the first string to the second string.
 *
 * @param string the string address
 * @param newString the new string address
 */

void stringChangeStringS(String *string, String *newString) {
    if (string == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "string", "string data structure");
        exit(NULL_POINTER);
#endif

    } else if (newString == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = INVALID_ARG;
        return;
#else
        fprintf(stderr, INVALID_ARG_MESSAGE, "new string pointer", "string data structure");
        exit(INVALID_ARG);
#endif

    }

    string->count = 0;
    string->string[string->count] = '\0';

    for (int i = 0; i < stringGetLength(newString); i++)
        stringAppendChar(string, stringGet(newString, i));


}


/** This function will take the string address, and the character as a parameters,
 * then it will return the first occur of this character in the string and will return it's index,
 * other wise it will return minus one (-1).
 *
 * @param string the string address
 * @param c the character value
 * @return it will return the first index of the provided character if found, other wise it will return -1
 */

int stringGetIndex(String *string, char c) {
    if (string == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return -1;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "string", "string data structure");
        exit(NULL_POINTER);
#endif

    }

    for (int i = 0; i < string->count; i++) {
        if (string->string[i] == c)
            return i;

    }

    return -1;

}


/** This function will take the string address, and the index as a parameters,
 * then it will return the character at the given index.
 *
 * Note: if the index is out of the string range the program will terminate.
 *
 * @param string the string address
 * @param index the index of the wanted character
 * @return it will return the character at the provided index
 */

char stringGet(String *string, int index) {
    if (string == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return '\0';
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "string", "string data structure");
        exit(NULL_POINTER);
#endif

    } else if (string->count <= index || index < 0) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = OUT_OF_RANGE;
        return '\0';
#else
        fprintf(stderr, OUT_OF_RANGE_MESSAGE, "string data structure");
        exit(OUT_OF_RANGE);
#endif

    }

    return string->string[index];

}


/** This function will take the charArr address, and a char pointer array as a parameters,
 * then it will return one (1) if the second char array is a substring of the first charArr,
 * other wise it will return zero (0).
 *
 * @param string the string address
 * @param charArr a char array address
 * @return it will return one if the provided char array are a substring of the original charArr
 */

int stringSubStringC(String *string, char *charArr) {
    if (string == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return -1;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "string", "string data structure");
        exit(NULL_POINTER);
#endif

    } else if (charArr == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = INVALID_ARG;
        return -1;
#else
        fprintf(stderr, INVALID_ARG_MESSAGE, "char array pointer", "string data structure");
        exit(INVALID_ARG);
#endif

    }

    char *stringPointer = string->string;

    while (*stringPointer != '\0') {

        if (*charArr == *stringPointer) {

            int counter = 0;
            while (charArr[counter] != '\0' && stringPointer[counter] != '\0') {

                if (charArr[counter] != stringPointer[counter])
                    break;
                else if (charArr[counter + 1] == '\0')
                    return 1;

                counter++;

            }

        }

        stringPointer++;

    }

    return 0;

}


/** This function will take a string address, and another string pointer as a parameters,
 * then it will return one (1) if the second string is a substring of the first string,
 * other wise it will return zero (0).
 *
 * @param string the string address
 * @param sString the second string pointer
 * @return it will return one if the provided string are a substring of the original string
 */

int stringSubStringS(String *string, String *sString) {
    if (string == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return -1;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "string", "string data structure");
        exit(NULL_POINTER);
#endif

    } else if (sString == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = INVALID_ARG;
        return -1;
#else
        fprintf(stderr, INVALID_ARG_MESSAGE, "second string pointer", "string data structure");
        exit(INVALID_ARG);
#endif

    }

    char *stringPointer = string->string;
    char *secondStringPointer = sString->string;

    while (*stringPointer != '\0') {

        if (*secondStringPointer == *stringPointer) {

            int counter = 0;
            while (secondStringPointer[counter] != '\0' && stringPointer[counter] != '\0') {

                if (secondStringPointer[counter] != stringPointer[counter])
                    break;
                else if (secondStringPointer[counter + 1] == '\0')
                    return 1;

                counter++;

            }

        }

        stringPointer++;

    }

    return 0;

}


/** This function will take the string address as a parameter,
 * then it will convert it to a char pointer array, and return it.
 *
 * @param string the string address
 * @return it will return a pointer to char array that has the same string of string
 */

char *stringToCharArray(String *string) {
    if (string == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return NULL;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "string", "string data structure");
        exit(NULL_POINTER);
#endif

    }

    char *arrayOfCharacters = (char *) malloc(sizeof(char) * (string->count + 1));
    if (arrayOfCharacters == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = FAILED_ALLOCATION;
        return NULL;
#else
        fprintf(stderr, FAILED_ALLOCATION_MESSAGE, "to array of characters", "string data structure");
        exit(FAILED_ALLOCATION);
#endif

    }

    for (int i = 0; i <= string->count; i++)
        arrayOfCharacters[i] = string->string[i];

    return arrayOfCharacters;
}


/** This method will take the string address, start index, and end index as a parameters,
 * then it will convert the string from the start index to the end index to a char pointer array, then return it.
 *
 * @param string the string address
 * @param startIndex the start index
 * @param endIndex the end index
 * @return it will return a pointer to character array, that has copy of the from the start index to the end index
 */

char *stringToCustomCharArray(String *string, int startIndex, int endIndex) {
    if (string == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return NULL;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "string", "string data structure");
        exit(NULL_POINTER);
#endif

    }

    if (startIndex > endIndex
        || startIndex < 0 || startIndex >= string->count
        || endIndex < 0 || endIndex >= string->count) {

#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = OUT_OF_RANGE;
        return NULL;
#else
        fprintf(stderr, OUT_OF_RANGE_MESSAGE, "string data structure");
        exit(OUT_OF_RANGE);
#endif

    }


    char *newCharArray = (char *) malloc(sizeof(char) * (endIndex - startIndex + 2));
    if (string == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = FAILED_ALLOCATION;
        return NULL;
#else
        fprintf(stderr, FAILED_ALLOCATION_MESSAGE, "string to custom char array", "string data structure");
        exit(FAILED_ALLOCATION);
#endif

    }

    newCharArray[endIndex - startIndex + 1] = '\0';
    for (int i = 0; i <= endIndex - startIndex; i++)
        newCharArray[i] = string->string[startIndex + i];

    return newCharArray;

}


/** This function will take the string address as a parameter,
 * then it will return the string length.
 *
 * @param string the string address
 * @return it will return the length of the string
 */

int stringGetLength(String *string) {
    if (string == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return -1;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "string", "string data structure");
        exit(NULL_POINTER);
#endif

    }

    return string->count;
}


/** This function will take the charArr address, and a char pointer array as a parameters,
 * then it will return one (1) if the charArr is equal to the char array,
 * other wise it will return zero (0).
 *
 * @param string the string address
 * @param charArr a character array pointer
 * @return it will return one if the provided char array is equal to the charArr, other wise in will return zero
 */

int stringEqualsC(String *string, char *charArr) {
    if (string == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return -1;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "string", "string data structure");
        exit(NULL_POINTER);
#endif

    } else if (charArr == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = INVALID_ARG;
        return -1;
#else
        fprintf(stderr, INVALID_ARG_MESSAGE, "char array pointer", "string data structure");
        exit(INVALID_ARG);
#endif

    }

    char *fS = string->string;
    char *sS = charArr;

    while (*fS != '\0' && *sS != '\0') {

        if (*fS != *sS)
            return 0;

        fS++;
        sS++;

    }

    return *fS == '\0' && *sS == '\0' ? 1 : 0;

}


/** This function will take the string address, and second string address as a parameters,
 * then it will return one (1) if the first string is equal to the second string,
 * other wise it will return zero (0).
 *
 * @param string the string address
 * @param sString the other sString address
 * @return it will return one if the second sString is equal to the original sString, other wise in will return zero
 */

int stringEqualsS(String *string, String *sString) {
    if (string == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return -1;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "string", "string data structure");
        exit(NULL_POINTER);
#endif

    } else if (sString == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = INVALID_ARG;
        return -1;
#else
        fprintf(stderr, INVALID_ARG_MESSAGE, "second string pointer", "string data structure");
        exit(INVALID_ARG);
#endif

    }

    int stringLength = stringGetLength(sString);
    if (string->count != stringLength)
        return 0;

    for (int i = 0; i < stringLength; i++) {

        if (string->string[i] != sString->string[i])
            return 0;

    }

    return 1;

}


/** This function will take the string address, and a char pointer array as a parameters,
 * then it will compare them and it will return a zero if they are equal,
 * negative number if the second one is bigger, and positive number if the first is bigger.
 *
 * @param string the string address
 * @param charArr a character array pointer
 * @return it will return a zero if they are equal, negative number if the second one is bigger, and positive number if the first is bigger.
*/

int stringCompareC(String *string, char *charArr) {
    if (string == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return -1;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "string", "string data structure");
        exit(NULL_POINTER);
#endif

    } else if (charArr == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = INVALID_ARG;
        return -1;
#else
        fprintf(stderr, INVALID_ARG_MESSAGE, "second char array pointer", "string data structure");
        exit(INVALID_ARG);
#endif

    }

    char *fS = string->string;
    char *sS = charArr;

    while (*fS != '\0' && *sS != '\0') {

        if (*fS != *sS)
            return *fS - *sS;

        fS++;
        sS++;

    }

    if (*fS == '\0' && *sS == '\0')
        return 0;

    return *fS == '\0' ? -1 * (int) *sS : (int) *fS;

}


/** This function will take the string address, and second string address as a parameters,
 * then it will compare the strings and it will return a zero if they are equal,
 * negative number if the second one is bigger, and positive number if the first is bigger.
 *
 * @param string the string address
 * @param sString the other string address
 * @return it will return a zero if they are equal, negative number if the second one is bigger, and positive number if the first is bigger.
*/

int stringCompareS(const void *string, const void *sString) {
    if (string == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return -1;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "string", "string data structure");
        exit(NULL_POINTER);
#endif

    } else if (sString == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = INVALID_ARG;
        return -1;
#else
        fprintf(stderr, INVALID_ARG_MESSAGE, "second string pointer", "string data structure");
        exit(INVALID_ARG);
#endif

    }

    char *fS = ((String *) string)->string;
    char *sS = ((String *) sString)->string;

    while (*fS != '\0' && *sS != '\0') {

        if (*fS != *sS)
            return *fS - *sS;

        fS++;
        sS++;

    }

    if (*fS == '\0' && *sS == '\0')
        return 0;

    return *fS == '\0' ? -1 * (int) *sS : (int) *fS;

}


/** This function will return one (1) if the passed characters is a part of the passed character array,
 * other wise if will return zero (0).
 *
 * @param charArr the char array pointer
 * @param c the character value, that the function will search for
 * @return it will return one if the character value exist in the char array, other wise it will return zero
 */

int charArrContains(char *charArr, char c) {

    while (*charArr != '\0') {
        if (*charArr++ == c)
            return 1;

    }

    return 0;

}


/** This function will take string pointer,
 * then it will removes characters specified in the second array of characters parameter,
 * from the beginning of the string.
 *
 * ex of specialCharacters array:
 * " \t\n", the function will remove any ' ', '\t', and '\n' characters from the beginning.
 *
 * @param string the string pointer
 * @param specialCharacters the special characters array pointer
 */

void stringCustomTrimStart(String *string, char *specialCharacters) {

    if (string == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "string", "string data structure");
        exit(NULL_POINTER);
#endif

    } else if (specialCharacters == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = INVALID_ARG;
        return;
#else
        fprintf(stderr, INVALID_ARG_MESSAGE, "special characters array", "string data structure");
        exit(INVALID_ARG);
#endif
    }

    char *charArr = string->string;
    while (*charArr != '\0') {

        if (charArrContains(specialCharacters, *charArr)) {
            char *tempPointer = charArr;

            do {
                *tempPointer = *(tempPointer + 1);
            } while (*tempPointer++ != '\0');

            string->count--;

        } else
            break;

    }


}


/** This function will take string pointer,
 * then it will remove ' ', '\t' and '\n' characters,
 * from the beginning of the string.
 *
 * @param string the string pointer
 */

void stringTrimStart(String *string) {

    if (string == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "string", "string data structure");
        exit(NULL_POINTER);
#endif
    }

    stringCustomTrimStart(string, " \n\t");

}


/** This function will take string pointer,
 * then it will removes characters specified in the second array of characters parameter,
 * from the end of the string.
 *
 * ex of specialCharacters array:
 * " \t\n", the function will remove any ' ', '\t', and '\n' characters from the end.
 *
 * @param string the string pointer
 * @param specialCharacters the special characters array pointer
 */

void stringCustomTrimEnd(String *string, char *specialCharacters) {

    if (string == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "string", "string data structure");
        exit(NULL_POINTER);
#endif

    } else if (specialCharacters == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = INVALID_ARG;
        return;
#else
        fprintf(stderr, INVALID_ARG_MESSAGE, "special characters array", "string data structure");
        exit(INVALID_ARG);
#endif
    }

    char *charArr = string->string;
    char *startPointer = string->string;

    while (*charArr != '\0')
        charArr++;

    while (startPointer - sizeof(char) != --charArr && charArrContains(specialCharacters, *charArr)) {
        *charArr = '\0';
        string->count--;
    }

}


/** This function will take string pointer,
 * then it will remove ' ', '\t' and '\n' characters,
 * from the end of the string.
 *
 *
 * @param string the string pointer
 */

void stringTrimEnd(String *string) {

    if (string == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "string", "string data structure");
        exit(NULL_POINTER);
#endif
    }

    stringCustomTrimEnd(string, " \n\t");

}


/** This function will take string pointer,
 * then it will remove ' ', '\t' and '\n' characters,
 * from the beginning and the end of the string.
 *
 *
 * @param myString the string pointer
 */

void stringTrim(String *myString) {

    if (myString == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "string", "string data structure");
        exit(NULL_POINTER);
#endif
    }

    stringCustomTrimStart(myString, " \n\t");
    stringCustomTrimEnd(myString, " \n\t");

}


/** This function will take string pointer,
 * then it will removes characters specified in the second array of characters parameter,
 * from the beginning and the end of the string.
 *
 * ex of specialCharacters array:
 * " \t\n", the function will remove any ' ', '\t', and '\n' characters from the beginning and the end.
 *
 * @param string the string pointer
 * @param specialCharacters the special characters array pointer
 */

void stringCustomTrim(String *string, char *specialCharacters) {

    if (string == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "string", "string data structure");
        exit(NULL_POINTER);
#endif
    } else if (specialCharacters == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = INVALID_ARG;
        return;
#else
        fprintf(stderr, INVALID_ARG_MESSAGE, "special characters array", "string data structure");
        exit(INVALID_ARG);
#endif
    }

    stringCustomTrimStart(string, specialCharacters);
    stringCustomTrimEnd(string, specialCharacters);

}


/** This function will take the string address as a parameter,
 * then it will read the input from the passed file and put it in the string.
 *
 * @param string the string address
 * @param dir the file pointer the the function will scan the input from it
 */

void stringScanInput(String *string, FILE *dir) {
    if (string == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "string", "string data structure");
        exit(NULL_POINTER);
#endif

    } else if (dir == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = INVALID_ARG;
        return;
#else
        fprintf(stderr, INVALID_ARG_MESSAGE, "file pointer", "string data structure");
        exit(INVALID_ARG);
#endif

    }

    char c;

    while (1) {
        c = fgetc(dir);

        if (c == '\n' || c == EOF)
            break;

        stringAppendChar(string, c);
    }

    if (string->string[string->count - 1] == '\r')
        stringRemove(string, string->count - 1);

    fseek(dir, 0, SEEK_END);

}


/** This function will take the string address as a parameter,
 * then it will print the string in the stdout file.
 *
 * @param string the string address
 * @param dir the file pointer that the function will print the string in it
 */

void printString(String *string, FILE *dir) {

    if (string == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "string", "string data structure");
        exit(NULL_POINTER);
#endif

    } else if (dir == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = INVALID_ARG;
        return;
#else
        fprintf(stderr, INVALID_ARG_MESSAGE, "file pointer", "string data structure");
        exit(INVALID_ARG);
#endif

    }

    fprintf(dir, "%s", string->string);

}


/** This function will take a string,
 * then it will split it by the passed split characters array.
 *
 * ex of split characters array:
 * " \t\n", the function will split the string when ever it see ' ', '\t', or '\n' characters.
 *
 * @param string the string pointer
 * @param splitCharacters the split characters array pointer
 * @return it will return a vector contains the strings after split
 */

Vector *stringSplit(String *string, char *splitCharacters) {

    if (string == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return NULL;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "string", "string data structure");
        exit(NULL_POINTER);
#endif

    } else if (splitCharacters == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = INVALID_ARG;
        return NULL;
#else
        fprintf(stderr, INVALID_ARG_MESSAGE, "split characters array", "string data structure");
        exit(INVALID_ARG);
#endif
    }


    Vector *stringsVector = vectorInitialization(5, destroyString, stringCompareS);
    vectorAdd(stringsVector, stringInitialization(5));

    for (int i = 0; i < stringGetLength(string); i++) {

        if (charArrContains(splitCharacters, stringGet(string, i))) {

            if (stringGetLength(vectorGet(stringsVector, vectorGetLength(stringsVector) - 1)) != 0)
                vectorAdd(stringsVector, stringInitialization(5));

            continue;
        }

        stringAppendChar(vectorGet(stringsVector, vectorGetLength(stringsVector) - 1), stringGet(string, i));

    }

    return stringsVector;

}


/** This function will clear the string.
 *
 * @param string the string pointer
 */

void clearString(String *string) {

    if (string == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "string", "string data structure");
        exit(NULL_POINTER);
#endif

    }

    string->count = 0;
    string->string[string->count] = '\0';

}


/** This function will take the string address as a parameter,
 * then it will destroy and free the string from the memory.
 *
 * @param myString the string address
 */

void destroyString(void *myString) {
    if (myString == NULL) {
#ifdef C_DATASTRUCTURES_ERRORSTESTSTRUCT_H
        ERROR_TEST->errorCode = NULL_POINTER;
        return;
#else
        fprintf(stderr, NULL_POINTER_MESSAGE, "string", "string data structure");
        exit(NULL_POINTER);
#endif

    }

    free(((String *) myString)->string);
    free(myString);

}

typedef struct Param {
    int m1R, m1C, m2R, m2C, *fMatrix, *sMatrix, *answerMatrix, r, c;
} Param;

void *calElement(void *p) {
    Param *param = (Param *) p;
    int m1R = param->m1R, m1C = param->m1C, m2R = param->m2R, m2C = param->m2C,
            *fMatrix = param->fMatrix, *sMatrix = param->sMatrix, *answerMatrix = param->answerMatrix, r = param->r, c = param->c;
    int sum = 0;

    for (int i = 0; i < m1C; i++) {
        sum += fMatrix[r * m1C + i] * sMatrix[i * m2C + c];
    }
    answerMatrix[r * m2C + c] = sum;
    pthread_exit(NULL);

}

void *calRow(void *p) {
    Param *param = (Param *) p;
    int m1R = param->m1R, m1C = param->m1C, m2R = param->m2R, m2C = param->m2C,
            *fMatrix = param->fMatrix, *sMatrix = param->sMatrix, *answerMatrix = param->answerMatrix, r = param->r;

    int sum;
    for (int i = 0; i < m2C; i++) {
        sum = 0;
        for (int j = 0; j < m1C; j++) {
            sum += fMatrix[r * m1C + j] * sMatrix[j * m2C + i];
        }
        answerMatrix[r * m2C + i] = sum;
    }

    pthread_exit(NULL);
}

int main() {

    double time_spent;
    clock_t begin, end;
    int m1R, m1C, m2R, m2C, currThread;

    char filePath[] = "C:\\Users\\mosta\\CLionProjects\\MatrixMultiplication\\input.txt";
    TxtFileLoader *txtFileLoader = txtFileLoaderInitialization(filePath);
    Vector *fileLines = txtLoaderReadFileLines(txtFileLoader);
    if (vectorGetLength(fileLines) < 4) {
        fprintf(stderr, "The file isn't valid.");
        exit(-1);
    }

    String *fMatrixSizeLine = vectorGet(fileLines, 0);
    Vector *fMatrixSizeSplitted = stringSplit(fMatrixSizeLine, " ");
    if (vectorGetLength(fMatrixSizeSplitted) != 2) {
        fprintf(stderr, "The file isn't valid.");
        exit(-1);
    }

    m1R = atoi(((String *) vectorGet(fMatrixSizeSplitted, 0))->string);
    m1C = atoi(((String *) vectorGet(fMatrixSizeSplitted, 1))->string);
    destroyString(fMatrixSizeLine);
    destroyVector(fMatrixSizeSplitted);
    Vector *splittedLine;

    int fMatrix[m1R][m1C];
    for (int i = 1; i <= m1R; i++) {
        splittedLine = stringSplit(vectorGet(fileLines, i), " ");
        if (vectorGetLength(splittedLine) != m1C) {
            fprintf(stderr, "The file isn't valid.");
            exit(-1);
        }
        for (int j = 0; j < m1C; j++)
            fMatrix[i - 1][j] = atoi(((String  *) vectorGet(splittedLine, j))->string);

        destroyVector(splittedLine);
    }


    String *sMatrixSizeLine = vectorGet(fileLines, m1R + 1);
    Vector *sMatrixSizeSplitted = stringSplit(sMatrixSizeLine, " ");
    if (vectorGetLength(sMatrixSizeSplitted) != 2) {
        fprintf(stderr, "The file isn't valid.");
        exit(-1);
    }

    m2R = atoi(((String *) vectorGet(sMatrixSizeSplitted, 0))->string);
    m2C = atoi(((String *) vectorGet(sMatrixSizeSplitted, 1))->string);
    destroyString(sMatrixSizeLine);
    destroyVector(sMatrixSizeSplitted);

    int sMatrix[m2R][m2C];
    for (int i = m1R + 2; i <= m2R + m1R + 1; i++) {
        splittedLine = stringSplit(vectorGet(fileLines, i), " ");
        if (vectorGetLength(splittedLine) != m2C) {
            fprintf(stderr, "The file isn't valid.");
            exit(-1);
        }
        for (int j = 0; j < m2C; j++)
            sMatrix[i - m1R - 2][j] = atoi(((String  *) vectorGet(splittedLine, j))->string);

        destroyVector(splittedLine);
    }

    destroyTxtFileLoader(txtFileLoader);
    destroyVector(fileLines);

    int answerMatrix[m1R][m2C];
    pthread_t threads_id[m1R * m2C];
    Param params[m1R * m2C];
    for (int i = 0; i < m1R * m2C; i++) {
        params[i].m1R = m1R;
        params[i].m1C = m1C;
        params[i].m2R = m2R;
        params[i].m2C = m2C;
        params[i].fMatrix = (int *) fMatrix;
        params[i].sMatrix = (int *) sMatrix;
        params[i].answerMatrix = (int *) answerMatrix;
    }

    // start of method 1:
    begin = clock();
    for (int i = 0; i < m1R; i++) {
        for (int j = 0; j < m2C; j++) {
            currThread = i * m2C + j;
            params[currThread].r = i;
            params[currThread].c = j;
            pthread_create(threads_id + currThread, NULL, calElement, params + currThread);
        }
    }

    for (int i = 0; i < m1R * m2C; i++) {
        if (pthread_join(threads_id[i], NULL))
            fprintf(stderr, "Some thing went wrong.");

    }

    end = clock();
    time_spent = (double)(end - begin) / CLOCKS_PER_SEC;

    printf("Answer by first procedure:\n");
    for (int i = 0; i < m1R; i++) {
        for (int j = 0; j < m2C; j++) {
            printf("%d%c", answerMatrix[i][j], j == m2C - 1 ? '\n' : ' ');
        }
    }

    printf("Time spent: %f s\n\n", time_spent);
    // finish of method 1.

    // start of method 2:
    begin = clock();

    for (int i = 0; i < m1R; i++) {
        currThread = i;
        params[currThread].r = i;
        pthread_create(threads_id + currThread, NULL, calRow, params + currThread);
    }

    for (int i = 0; i < m1R; i++) {
        if (pthread_join(threads_id[i], NULL))
            fprintf(stderr, "Some thing went wrong.");

    }

    end = clock();
    time_spent = (double)(end - begin) / CLOCKS_PER_SEC;

    printf("Answer by second procedure:\n");
    for (int i = 0; i < m1R; i++) {
        for (int j = 0; j < m2C; j++) {
            printf("%d%c", answerMatrix[i][j], j == m2C - 1 ? '\n' : ' ');
        }
    }

    printf("Time spent: %f s\n", time_spent);
    // end of method 2.

    return 0;
}
